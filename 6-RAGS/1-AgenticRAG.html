
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Agentic RAG &#8212; Agentic AI Tutorials</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '6-RAGS/1-AgenticRAG';</script>
    <link rel="canonical" href="/6-RAGS/1-AgenticRAG.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../introduction.html">
  
  
  
  
  
  
    <p class="title logo__title">Agentic AI Tutorials</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../1-langgraph%20Basics/1-simplegraph.html">Build a Simple Workflow or Graph Using LangGraph</a></li>

<li class="toctree-l1"><a class="reference internal" href="../1-langgraph%20Basics/2-chatbot.html">Implementing simple Chatbot Using LangGraph</a></li>

<li class="toctree-l1"><a class="reference internal" href="../1-langgraph%20Basics/3-DataclassStateSchema.html">State Schema With DataClasses</a></li>

<li class="toctree-l1"><a class="reference internal" href="../1-langgraph%20Basics/4-pydantic.html">Pydantic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1-langgraph%20Basics/5-ChainsLangGraph.html">Chain Using LangGraph</a></li>




<li class="toctree-l1"><a class="reference internal" href="../1-langgraph%20Basics/6-chatbotswithmultipletools.html">Chatbots with Multiple Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1-langgraph%20Basics/7-ReActAgents.html">ReAct Agent Architecture</a></li>

<li class="toctree-l1"><a class="reference internal" href="../2-langgraph%20advance/1-streaming.html">Implementing simple Chatbot Using LangGraph</a></li>


<li class="toctree-l1"><a class="reference internal" href="../4-%20Workflows/1-prompting_chaining.html">Prompt Chaining</a></li>

<li class="toctree-l1"><a class="reference internal" href="../4-%20Workflows/2-parallelization.html">What is Parallelization in LangGraph?</a></li>


<li class="toctree-l1"><a class="reference internal" href="../4-%20Workflows/3-Routing.html">What is Routing in LangGraph?</a></li>

<li class="toctree-l1"><a class="reference internal" href="../4-%20Workflows/4-orchestrator-worker.html">Orchestrator-Worker</a></li>

<li class="toctree-l1"><a class="reference internal" href="../4-%20Workflows/5-Evaluator-optimizer.html">Evaluator-Optimizer Pattern</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pydantic/intro.html">Pydantic Basics: Creating and Using Models</a></li>



</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/6-RAGS/1-AgenticRAG.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Agentic RAG</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Agentic RAG</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#langchain-blogs-seperate-vector-store">Langchain Blogs- Seperate Vector Store</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#langgraph-workflow">LangGraph Workflow</a></li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="agentic-rag">
<h1>Agentic RAG<a class="headerlink" href="#agentic-rag" title="Link to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dotenv</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_dotenv</span>
<span class="n">load_dotenv</span><span class="p">()</span>

<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;GROQ_API_KEY&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;GROQ_API_KEY&quot;</span><span class="p">)</span>
<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;OPENAI_API_KEY&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;OPENAI_API_KEY&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">langchain_community.document_loaders</span><span class="w"> </span><span class="kn">import</span> <span class="n">WebBaseLoader</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">langchain_community.vectorstores</span><span class="w"> </span><span class="kn">import</span> <span class="n">FAISS</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">langchain_openai</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpenAIEmbeddings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">langchain_text_splitters</span><span class="w"> </span><span class="kn">import</span> <span class="n">RecursiveCharacterTextSplitter</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>USER_AGENT environment variable not set, consider setting it to identify your requests.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">urls</span><span class="o">=</span><span class="p">[</span>
    <span class="s2">&quot;https://langchain-ai.github.io/langgraph/tutorials/introduction/&quot;</span><span class="p">,</span>
    <span class="s2">&quot;https://langchain-ai.github.io/langgraph/tutorials/workflows/&quot;</span><span class="p">,</span>
    <span class="s2">&quot;https://langchain-ai.github.io/langgraph/how-tos/map-reduce/&quot;</span>
<span class="p">]</span>

<span class="n">docs</span><span class="o">=</span><span class="p">[</span><span class="n">WebBaseLoader</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
<span class="n">docs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[Document(metadata={&#39;source&#39;: &#39;https://langchain-ai.github.io/langgraph/tutorials/introduction/&#39;, &#39;title&#39;: &#39;Redirecting...&#39;, &#39;language&#39;: &#39;en&#39;}, page_content=&#39;\n\n\n\n\nRedirecting...\n\n\n\n\n\n\nRedirecting...\n\n\n&#39;)],
 [Document(metadata={&#39;source&#39;: &#39;https://langchain-ai.github.io/langgraph/tutorials/workflows/&#39;, &#39;title&#39;: &#39;Workflows &amp; agents&#39;, &#39;description&#39;: &#39;Build reliable, stateful AI systems, without giving up control&#39;, &#39;language&#39;: &#39;en&#39;}, page_content=&#39;\n\n\n\n\n\n\n\n\n\n\n\nWorkflows &amp; agents\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Skip to content\n        \n\n\n\n\n\n\n\n            \n            \nThese docs will be deprecated and removed with the release of LangGraph v1.0 in October 2025. Visit the v1.0 alpha docs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            LangGraph\n          \n\n\n\n            \n              Workflows &amp; agents\n            \n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Initializing search\n          \n\n\n\n\n\n\n\n\n\n\n\n\n    GitHub\n  \n\n\n\n\n\n\n\n\n\n\n          \n  \n  \n    \n  \n  Get started\n\n        \n\n\n\n          \n  \n  \n    \n  \n  Guides\n\n        \n\n\n\n          \n  \n  \n    \n  \n  Reference\n\n        \n\n\n\n          \n  \n  \n    \n  \n  Examples\n\n        \n\n\n\n          \n  \n  \n    \n  \n  Additional resources\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    LangGraph\n  \n\n\n\n\n\n\n    GitHub\n  \n\n\n\n\n\n\n\n\n    Get started\n    \n  \n\n\n\n\n\n\n\n\n            Get started\n          \n\n\n\n\n\n    Quickstarts\n    \n  \n\n\n\n\n\n            Quickstarts\n          \n\n\n\n\n    Start with a prebuilt agent\n    \n  \n\n\n\n\n\n    Build a custom workflow\n    \n  \n\n\n\n\n\n\n    Run a local server\n    \n  \n\n\n\n\n\n\n\n\n\n    General concepts\n    \n  \n\n\n\n\n\n            General concepts\n          \n\n\n\n\n\n    Workflows &amp; agents\n    \n  \n\n\n\n\n    Workflows &amp; agents\n    \n  \n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Set up\n    \n\n\n\n\n\n      Building Blocks: The Augmented LLM\n    \n\n\n\n\n\n      Prompt chaining\n    \n\n\n\n\n\n      Parallelization\n    \n\n\n\n\n\n      Routing\n    \n\n\n\n\n\n      Orchestrator-Worker\n    \n\n\n\n\n\n      Evaluator-optimizer\n    \n\n\n\n\n\n      Agent\n    \n\n\n\n\n\n\n      Pre-built\n    \n\n\n\n\n\n\n\n\n      What LangGraph provides\n    \n\n\n\n\n\n\n      Persistence: Human-in-the-Loop\n    \n\n\n\n\n\n      Persistence: Memory\n    \n\n\n\n\n\n      Streaming\n    \n\n\n\n\n\n      Deployment\n    \n\n\n\n\n\n\n\n\n\n\n\n    Agent architectures\n    \n  \n\n\n\n\n\n\n\n\n\n\n\n    Guides\n    \n  \n\n\n\n\n\n\n    Reference\n    \n  \n\n\n\n\n\n\n    Examples\n    \n  \n\n\n\n\n\n\n    Additional resources\n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Set up\n    \n\n\n\n\n\n      Building Blocks: The Augmented LLM\n    \n\n\n\n\n\n      Prompt chaining\n    \n\n\n\n\n\n      Parallelization\n    \n\n\n\n\n\n      Routing\n    \n\n\n\n\n\n      Orchestrator-Worker\n    \n\n\n\n\n\n      Evaluator-optimizer\n    \n\n\n\n\n\n      Agent\n    \n\n\n\n\n\n\n      Pre-built\n    \n\n\n\n\n\n\n\n\n      What LangGraph provides\n    \n\n\n\n\n\n\n      Persistence: Human-in-the-Loop\n    \n\n\n\n\n\n      Persistence: Memory\n    \n\n\n\n\n\n      Streaming\n    \n\n\n\n\n\n      Deployment\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWorkflows and Agents¶\nThis guide reviews common patterns for agentic systems. In describing these systems, it can be useful to make a distinction between &quot;workflows&quot; and &quot;agents&quot;. One way to think about this difference is nicely explained in Anthropic\&#39;s Building Effective Agents blog post:\n\nWorkflows are systems where LLMs and tools are orchestrated through predefined code paths.\nAgents, on the other hand, are systems where LLMs dynamically direct their own processes and tool usage, maintaining control over how they accomplish tasks.\n\nHere is a simple way to visualize these differences:\n\nWhen building agents and workflows, LangGraph offers a number of benefits including persistence, streaming, and support for debugging as well as deployment.\nSet up¶\nYou can use any chat model that supports structured outputs and tool calling. Below, we show the process of installing the packages, setting API keys, and testing structured outputs / tool calling for Anthropic.\n\nInstall dependencies\npip install langchain_core langchain-anthropic langgraph\n\n\nInitialize an LLM\nAPI Reference: ChatAnthropic\nimport os\nimport getpass\n\nfrom langchain_anthropic import ChatAnthropic\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f&quot;{var}: &quot;)\n\n\n_set_env(&quot;ANTHROPIC_API_KEY&quot;)\n\nllm = ChatAnthropic(model=&quot;claude-3-5-sonnet-latest&quot;)\n\nBuilding Blocks: The Augmented LLM¶\nLLM have augmentations that support building workflows and agents. These include structured outputs and tool calling, as shown in this image from the Anthropic blog on Building Effective Agents:\n\n# Schema for structured output\nfrom pydantic import BaseModel, Field\n\nclass SearchQuery(BaseModel):\n    search_query: str = Field(None, description=&quot;Query that is optimized web search.&quot;)\n    justification: str = Field(\n        None, description=&quot;Why this query is relevant to the user\&#39;s request.&quot;\n    )\n\n\n# Augment the LLM with schema for structured output\nstructured_llm = llm.with_structured_output(SearchQuery)\n\n# Invoke the augmented LLM\noutput = structured_llm.invoke(&quot;How does Calcium CT score relate to high cholesterol?&quot;)\n\n# Define a tool\ndef multiply(a: int, b: int) -&gt; int:\n    return a * b\n\n# Augment the LLM with tools\nllm_with_tools = llm.bind_tools([multiply])\n\n# Invoke the LLM with input that triggers the tool call\nmsg = llm_with_tools.invoke(&quot;What is 2 times 3?&quot;)\n\n# Get the tool call\nmsg.tool_calls\n\nPrompt chaining¶\nIn prompt chaining, each LLM call processes the output of the previous one.\nAs noted in the Anthropic blog on Building Effective Agents:\n\nPrompt chaining decomposes a task into a sequence of steps, where each LLM call processes the output of the previous one. You can add programmatic checks (see &quot;gate&quot; in the diagram below) on any intermediate steps to ensure that the process is still on track.\nWhen to use this workflow: This workflow is ideal for situations where the task can be easily and cleanly decomposed into fixed subtasks. The main goal is to trade off latency for higher accuracy, by making each LLM call an easier task.\n\n\nGraph APIFunctional API\n\n\nfrom typing_extensions import TypedDict\nfrom langgraph.graph import StateGraph, START, END\nfrom IPython.display import Image, display\n\n\n# Graph state\nclass State(TypedDict):\n    topic: str\n    joke: str\n    improved_joke: str\n    final_joke: str\n\n\n# Nodes\ndef generate_joke(state: State):\n    &quot;&quot;&quot;First LLM call to generate initial joke&quot;&quot;&quot;\n\n    msg = llm.invoke(f&quot;Write a short joke about {state[\&#39;topic\&#39;]}&quot;)\n    return {&quot;joke&quot;: msg.content}\n\n\ndef check_punchline(state: State):\n    &quot;&quot;&quot;Gate function to check if the joke has a punchline&quot;&quot;&quot;\n\n    # Simple check - does the joke contain &quot;?&quot; or &quot;!&quot;\n    if &quot;?&quot; in state[&quot;joke&quot;] or &quot;!&quot; in state[&quot;joke&quot;]:\n        return &quot;Pass&quot;\n    return &quot;Fail&quot;\n\n\ndef improve_joke(state: State):\n    &quot;&quot;&quot;Second LLM call to improve the joke&quot;&quot;&quot;\n\n    msg = llm.invoke(f&quot;Make this joke funnier by adding wordplay: {state[\&#39;joke\&#39;]}&quot;)\n    return {&quot;improved_joke&quot;: msg.content}\n\n\ndef polish_joke(state: State):\n    &quot;&quot;&quot;Third LLM call for final polish&quot;&quot;&quot;\n\n    msg = llm.invoke(f&quot;Add a surprising twist to this joke: {state[\&#39;improved_joke\&#39;]}&quot;)\n    return {&quot;final_joke&quot;: msg.content}\n\n\n# Build workflow\nworkflow = StateGraph(State)\n\n# Add nodes\nworkflow.add_node(&quot;generate_joke&quot;, generate_joke)\nworkflow.add_node(&quot;improve_joke&quot;, improve_joke)\nworkflow.add_node(&quot;polish_joke&quot;, polish_joke)\n\n# Add edges to connect nodes\nworkflow.add_edge(START, &quot;generate_joke&quot;)\nworkflow.add_conditional_edges(\n    &quot;generate_joke&quot;, check_punchline, {&quot;Fail&quot;: &quot;improve_joke&quot;, &quot;Pass&quot;: END}\n)\nworkflow.add_edge(&quot;improve_joke&quot;, &quot;polish_joke&quot;)\nworkflow.add_edge(&quot;polish_joke&quot;, END)\n\n# Compile\nchain = workflow.compile()\n\n# Show workflow\ndisplay(Image(chain.get_graph().draw_mermaid_png()))\n\n# Invoke\nstate = chain.invoke({&quot;topic&quot;: &quot;cats&quot;})\nprint(&quot;Initial joke:&quot;)\nprint(state[&quot;joke&quot;])\nprint(&quot;\\n--- --- ---\\n&quot;)\nif &quot;improved_joke&quot; in state:\n    print(&quot;Improved joke:&quot;)\n    print(state[&quot;improved_joke&quot;])\n    print(&quot;\\n--- --- ---\\n&quot;)\n\n    print(&quot;Final joke:&quot;)\n    print(state[&quot;final_joke&quot;])\nelse:\n    print(&quot;Joke failed quality gate - no punchline detected!&quot;)\n\nLangSmith Trace\nhttps://smith.langchain.com/public/a0281fca-3a71-46de-beee-791468607b75/r\nResources:\nLangChain Academy\nSee our lesson on Prompt Chaining here.\n\n\nfrom langgraph.func import entrypoint, task\n\n\n# Tasks\n@task\ndef generate_joke(topic: str):\n    &quot;&quot;&quot;First LLM call to generate initial joke&quot;&quot;&quot;\n    msg = llm.invoke(f&quot;Write a short joke about {topic}&quot;)\n    return msg.content\n\n\ndef check_punchline(joke: str):\n    &quot;&quot;&quot;Gate function to check if the joke has a punchline&quot;&quot;&quot;\n    # Simple check - does the joke contain &quot;?&quot; or &quot;!&quot;\n    if &quot;?&quot; in joke or &quot;!&quot; in joke:\n        return &quot;Fail&quot;\n\n    return &quot;Pass&quot;\n\n\n@task\ndef improve_joke(joke: str):\n    &quot;&quot;&quot;Second LLM call to improve the joke&quot;&quot;&quot;\n    msg = llm.invoke(f&quot;Make this joke funnier by adding wordplay: {joke}&quot;)\n    return msg.content\n\n\n@task\ndef polish_joke(joke: str):\n    &quot;&quot;&quot;Third LLM call for final polish&quot;&quot;&quot;\n    msg = llm.invoke(f&quot;Add a surprising twist to this joke: {joke}&quot;)\n    return msg.content\n\n\n@entrypoint()\ndef prompt_chaining_workflow(topic: str):\n    original_joke = generate_joke(topic).result()\n    if check_punchline(original_joke) == &quot;Pass&quot;:\n        return original_joke\n\n    improved_joke = improve_joke(original_joke).result()\n    return polish_joke(improved_joke).result()\n\n# Invoke\nfor step in prompt_chaining_workflow.stream(&quot;cats&quot;, stream_mode=&quot;updates&quot;):\n    print(step)\n    print(&quot;\\n&quot;)\n\nLangSmith Trace\nhttps://smith.langchain.com/public/332fa4fc-b6ca-416e-baa3-161625e69163/r\n\n\n\nParallelization¶\nWith parallelization, LLMs work simultaneously on a task:\n\nLLMs can sometimes work simultaneously on a task and have their outputs aggregated programmatically. This workflow, parallelization, manifests in two key variations: Sectioning: Breaking a task into independent subtasks run in parallel. Voting: Running the same task multiple times to get diverse outputs.\nWhen to use this workflow: Parallelization is effective when the divided subtasks can be parallelized for speed, or when multiple perspectives or attempts are needed for higher confidence results. For complex tasks with multiple considerations, LLMs generally perform better when each consideration is handled by a separate LLM call, allowing focused attention on each specific aspect.\n\n\nGraph APIFunctional API\n\n\n# Graph state\nclass State(TypedDict):\n    topic: str\n    joke: str\n    story: str\n    poem: str\n    combined_output: str\n\n\n# Nodes\ndef call_llm_1(state: State):\n    &quot;&quot;&quot;First LLM call to generate initial joke&quot;&quot;&quot;\n\n    msg = llm.invoke(f&quot;Write a joke about {state[\&#39;topic\&#39;]}&quot;)\n    return {&quot;joke&quot;: msg.content}\n\n\ndef call_llm_2(state: State):\n    &quot;&quot;&quot;Second LLM call to generate story&quot;&quot;&quot;\n\n    msg = llm.invoke(f&quot;Write a story about {state[\&#39;topic\&#39;]}&quot;)\n    return {&quot;story&quot;: msg.content}\n\n\ndef call_llm_3(state: State):\n    &quot;&quot;&quot;Third LLM call to generate poem&quot;&quot;&quot;\n\n    msg = llm.invoke(f&quot;Write a poem about {state[\&#39;topic\&#39;]}&quot;)\n    return {&quot;poem&quot;: msg.content}\n\n\ndef aggregator(state: State):\n    &quot;&quot;&quot;Combine the joke and story into a single output&quot;&quot;&quot;\n\n    combined = f&quot;Here\&#39;s a story, joke, and poem about {state[\&#39;topic\&#39;]}!\\n\\n&quot;\n    combined += f&quot;STORY:\\n{state[\&#39;story\&#39;]}\\n\\n&quot;\n    combined += f&quot;JOKE:\\n{state[\&#39;joke\&#39;]}\\n\\n&quot;\n    combined += f&quot;POEM:\\n{state[\&#39;poem\&#39;]}&quot;\n    return {&quot;combined_output&quot;: combined}\n\n\n# Build workflow\nparallel_builder = StateGraph(State)\n\n# Add nodes\nparallel_builder.add_node(&quot;call_llm_1&quot;, call_llm_1)\nparallel_builder.add_node(&quot;call_llm_2&quot;, call_llm_2)\nparallel_builder.add_node(&quot;call_llm_3&quot;, call_llm_3)\nparallel_builder.add_node(&quot;aggregator&quot;, aggregator)\n\n# Add edges to connect nodes\nparallel_builder.add_edge(START, &quot;call_llm_1&quot;)\nparallel_builder.add_edge(START, &quot;call_llm_2&quot;)\nparallel_builder.add_edge(START, &quot;call_llm_3&quot;)\nparallel_builder.add_edge(&quot;call_llm_1&quot;, &quot;aggregator&quot;)\nparallel_builder.add_edge(&quot;call_llm_2&quot;, &quot;aggregator&quot;)\nparallel_builder.add_edge(&quot;call_llm_3&quot;, &quot;aggregator&quot;)\nparallel_builder.add_edge(&quot;aggregator&quot;, END)\nparallel_workflow = parallel_builder.compile()\n\n# Show workflow\ndisplay(Image(parallel_workflow.get_graph().draw_mermaid_png()))\n\n# Invoke\nstate = parallel_workflow.invoke({&quot;topic&quot;: &quot;cats&quot;})\nprint(state[&quot;combined_output&quot;])\n\nLangSmith Trace\nhttps://smith.langchain.com/public/3be2e53c-ca94-40dd-934f-82ff87fac277/r\nResources:\nDocumentation\nSee our documentation on parallelization here.\nLangChain Academy\nSee our lesson on parallelization here.\n\n\n@task\ndef call_llm_1(topic: str):\n    &quot;&quot;&quot;First LLM call to generate initial joke&quot;&quot;&quot;\n    msg = llm.invoke(f&quot;Write a joke about {topic}&quot;)\n    return msg.content\n\n\n@task\ndef call_llm_2(topic: str):\n    &quot;&quot;&quot;Second LLM call to generate story&quot;&quot;&quot;\n    msg = llm.invoke(f&quot;Write a story about {topic}&quot;)\n    return msg.content\n\n\n@task\ndef call_llm_3(topic):\n    &quot;&quot;&quot;Third LLM call to generate poem&quot;&quot;&quot;\n    msg = llm.invoke(f&quot;Write a poem about {topic}&quot;)\n    return msg.content\n\n\n@task\ndef aggregator(topic, joke, story, poem):\n    &quot;&quot;&quot;Combine the joke and story into a single output&quot;&quot;&quot;\n\n    combined = f&quot;Here\&#39;s a story, joke, and poem about {topic}!\\n\\n&quot;\n    combined += f&quot;STORY:\\n{story}\\n\\n&quot;\n    combined += f&quot;JOKE:\\n{joke}\\n\\n&quot;\n    combined += f&quot;POEM:\\n{poem}&quot;\n    return combined\n\n\n# Build workflow\n@entrypoint()\ndef parallel_workflow(topic: str):\n    joke_fut = call_llm_1(topic)\n    story_fut = call_llm_2(topic)\n    poem_fut = call_llm_3(topic)\n    return aggregator(\n        topic, joke_fut.result(), story_fut.result(), poem_fut.result()\n    ).result()\n\n# Invoke\nfor step in parallel_workflow.stream(&quot;cats&quot;, stream_mode=&quot;updates&quot;):\n    print(step)\n    print(&quot;\\n&quot;)\n\nLangSmith Trace\nhttps://smith.langchain.com/public/623d033f-e814-41e9-80b1-75e6abb67801/r\n\n\n\nRouting¶\nRouting classifies an input and directs it to a followup task. As noted in the Anthropic blog on Building Effective Agents:\n\nRouting classifies an input and directs it to a specialized followup task. This workflow allows for separation of concerns, and building more specialized prompts. Without this workflow, optimizing for one kind of input can hurt performance on other inputs.\nWhen to use this workflow: Routing works well for complex tasks where there are distinct categories that are better handled separately, and where classification can be handled accurately, either by an LLM or a more traditional classification model/algorithm.\n\n\nGraph APIFunctional API\n\n\nfrom typing_extensions import Literal\nfrom langchain_core.messages import HumanMessage, SystemMessage\n\n\n# Schema for structured output to use as routing logic\nclass Route(BaseModel):\n    step: Literal[&quot;poem&quot;, &quot;story&quot;, &quot;joke&quot;] = Field(\n        None, description=&quot;The next step in the routing process&quot;\n    )\n\n\n# Augment the LLM with schema for structured output\nrouter = llm.with_structured_output(Route)\n\n\n# State\nclass State(TypedDict):\n    input: str\n    decision: str\n    output: str\n\n\n# Nodes\ndef llm_call_1(state: State):\n    &quot;&quot;&quot;Write a story&quot;&quot;&quot;\n\n    result = llm.invoke(state[&quot;input&quot;])\n    return {&quot;output&quot;: result.content}\n\n\ndef llm_call_2(state: State):\n    &quot;&quot;&quot;Write a joke&quot;&quot;&quot;\n\n    result = llm.invoke(state[&quot;input&quot;])\n    return {&quot;output&quot;: result.content}\n\n\ndef llm_call_3(state: State):\n    &quot;&quot;&quot;Write a poem&quot;&quot;&quot;\n\n    result = llm.invoke(state[&quot;input&quot;])\n    return {&quot;output&quot;: result.content}\n\n\ndef llm_call_router(state: State):\n    &quot;&quot;&quot;Route the input to the appropriate node&quot;&quot;&quot;\n\n    # Run the augmented LLM with structured output to serve as routing logic\n    decision = router.invoke(\n        [\n            SystemMessage(\n                content=&quot;Route the input to story, joke, or poem based on the user\&#39;s request.&quot;\n            ),\n            HumanMessage(content=state[&quot;input&quot;]),\n        ]\n    )\n\n    return {&quot;decision&quot;: decision.step}\n\n\n# Conditional edge function to route to the appropriate node\ndef route_decision(state: State):\n    # Return the node name you want to visit next\n    if state[&quot;decision&quot;] == &quot;story&quot;:\n        return &quot;llm_call_1&quot;\n    elif state[&quot;decision&quot;] == &quot;joke&quot;:\n        return &quot;llm_call_2&quot;\n    elif state[&quot;decision&quot;] == &quot;poem&quot;:\n        return &quot;llm_call_3&quot;\n\n\n# Build workflow\nrouter_builder = StateGraph(State)\n\n# Add nodes\nrouter_builder.add_node(&quot;llm_call_1&quot;, llm_call_1)\nrouter_builder.add_node(&quot;llm_call_2&quot;, llm_call_2)\nrouter_builder.add_node(&quot;llm_call_3&quot;, llm_call_3)\nrouter_builder.add_node(&quot;llm_call_router&quot;, llm_call_router)\n\n# Add edges to connect nodes\nrouter_builder.add_edge(START, &quot;llm_call_router&quot;)\nrouter_builder.add_conditional_edges(\n    &quot;llm_call_router&quot;,\n    route_decision,\n    {  # Name returned by route_decision : Name of next node to visit\n        &quot;llm_call_1&quot;: &quot;llm_call_1&quot;,\n        &quot;llm_call_2&quot;: &quot;llm_call_2&quot;,\n        &quot;llm_call_3&quot;: &quot;llm_call_3&quot;,\n    },\n)\nrouter_builder.add_edge(&quot;llm_call_1&quot;, END)\nrouter_builder.add_edge(&quot;llm_call_2&quot;, END)\nrouter_builder.add_edge(&quot;llm_call_3&quot;, END)\n\n# Compile workflow\nrouter_workflow = router_builder.compile()\n\n# Show the workflow\ndisplay(Image(router_workflow.get_graph().draw_mermaid_png()))\n\n# Invoke\nstate = router_workflow.invoke({&quot;input&quot;: &quot;Write me a joke about cats&quot;})\nprint(state[&quot;output&quot;])\n\nLangSmith Trace\nhttps://smith.langchain.com/public/c4580b74-fe91-47e4-96fe-7fac598d509c/r\nResources:\nLangChain Academy\nSee our lesson on routing here.\nExamples\nHere is RAG workflow that routes questions. See our video here.\n\n\nfrom typing_extensions import Literal\nfrom pydantic import BaseModel\nfrom langchain_core.messages import HumanMessage, SystemMessage\n\n\n# Schema for structured output to use as routing logic\nclass Route(BaseModel):\n    step: Literal[&quot;poem&quot;, &quot;story&quot;, &quot;joke&quot;] = Field(\n        None, description=&quot;The next step in the routing process&quot;\n    )\n\n\n# Augment the LLM with schema for structured output\nrouter = llm.with_structured_output(Route)\n\n\n@task\ndef llm_call_1(input_: str):\n    &quot;&quot;&quot;Write a story&quot;&quot;&quot;\n    result = llm.invoke(input_)\n    return result.content\n\n\n@task\ndef llm_call_2(input_: str):\n    &quot;&quot;&quot;Write a joke&quot;&quot;&quot;\n    result = llm.invoke(input_)\n    return result.content\n\n\n@task\ndef llm_call_3(input_: str):\n    &quot;&quot;&quot;Write a poem&quot;&quot;&quot;\n    result = llm.invoke(input_)\n    return result.content\n\n\ndef llm_call_router(input_: str):\n    &quot;&quot;&quot;Route the input to the appropriate node&quot;&quot;&quot;\n    # Run the augmented LLM with structured output to serve as routing logic\n    decision = router.invoke(\n        [\n            SystemMessage(\n                content=&quot;Route the input to story, joke, or poem based on the user\&#39;s request.&quot;\n            ),\n            HumanMessage(content=input_),\n        ]\n    )\n    return decision.step\n\n\n# Create workflow\n@entrypoint()\ndef router_workflow(input_: str):\n    next_step = llm_call_router(input_)\n    if next_step == &quot;story&quot;:\n        llm_call = llm_call_1\n    elif next_step == &quot;joke&quot;:\n        llm_call = llm_call_2\n    elif next_step == &quot;poem&quot;:\n        llm_call = llm_call_3\n\n    return llm_call(input_).result()\n\n# Invoke\nfor step in router_workflow.stream(&quot;Write me a joke about cats&quot;, stream_mode=&quot;updates&quot;):\n    print(step)\n    print(&quot;\\n&quot;)\n\nLangSmith Trace\nhttps://smith.langchain.com/public/5e2eb979-82dd-402c-b1a0-a8cceaf2a28a/r\n\n\n\nOrchestrator-Worker¶\nWith orchestrator-worker, an orchestrator breaks down a task and delegates each sub-task to workers. As noted in the Anthropic blog on Building Effective Agents:\n\nIn the orchestrator-workers workflow, a central LLM dynamically breaks down tasks, delegates them to worker LLMs, and synthesizes their results.\nWhen to use this workflow: This workflow is well-suited for complex tasks where you can\&#39;t predict the subtasks needed (in coding, for example, the number of files that need to be changed and the nature of the change in each file likely depend on the task). Whereas it\&#39;s topographically similar, the key difference from parallelization is its flexibility—subtasks aren\&#39;t pre-defined, but determined by the orchestrator based on the specific input.\n\n\nGraph APIFunctional API\n\n\nfrom typing import Annotated, List\nimport operator\n\n\n# Schema for structured output to use in planning\nclass Section(BaseModel):\n    name: str = Field(\n        description=&quot;Name for this section of the report.&quot;,\n    )\n    description: str = Field(\n        description=&quot;Brief overview of the main topics and concepts to be covered in this section.&quot;,\n    )\n\n\nclass Sections(BaseModel):\n    sections: List[Section] = Field(\n        description=&quot;Sections of the report.&quot;,\n    )\n\n\n# Augment the LLM with schema for structured output\nplanner = llm.with_structured_output(Sections)\n\nCreating Workers in LangGraph\nBecause orchestrator-worker workflows are common, LangGraph has the Send API to support this. It lets you dynamically create worker nodes and send each one a specific input. Each worker has its own state, and all worker outputs are written to a shared state key that is accessible to the orchestrator graph. This gives the orchestrator access to all worker output and allows it to synthesize them into a final output. As you can see below, we iterate over a list of sections and Send each to a worker node. See further documentation here and here.\nfrom langgraph.types import Send\n\n\n# Graph state\nclass State(TypedDict):\n    topic: str  # Report topic\n    sections: list[Section]  # List of report sections\n    completed_sections: Annotated[\n        list, operator.add\n    ]  # All workers write to this key in parallel\n    final_report: str  # Final report\n\n\n# Worker state\nclass WorkerState(TypedDict):\n    section: Section\n    completed_sections: Annotated[list, operator.add]\n\n\n# Nodes\ndef orchestrator(state: State):\n    &quot;&quot;&quot;Orchestrator that generates a plan for the report&quot;&quot;&quot;\n\n    # Generate queries\n    report_sections = planner.invoke(\n        [\n            SystemMessage(content=&quot;Generate a plan for the report.&quot;),\n            HumanMessage(content=f&quot;Here is the report topic: {state[\&#39;topic\&#39;]}&quot;),\n        ]\n    )\n\n    return {&quot;sections&quot;: report_sections.sections}\n\n\ndef llm_call(state: WorkerState):\n    &quot;&quot;&quot;Worker writes a section of the report&quot;&quot;&quot;\n\n    # Generate section\n    section = llm.invoke(\n        [\n            SystemMessage(\n                content=&quot;Write a report section following the provided name and description. Include no preamble for each section. Use markdown formatting.&quot;\n            ),\n            HumanMessage(\n                content=f&quot;Here is the section name: {state[\&#39;section\&#39;].name} and description: {state[\&#39;section\&#39;].description}&quot;\n            ),\n        ]\n    )\n\n    # Write the updated section to completed sections\n    return {&quot;completed_sections&quot;: [section.content]}\n\n\ndef synthesizer(state: State):\n    &quot;&quot;&quot;Synthesize full report from sections&quot;&quot;&quot;\n\n    # List of completed sections\n    completed_sections = state[&quot;completed_sections&quot;]\n\n    # Format completed section to str to use as context for final sections\n    completed_report_sections = &quot;\\n\\n---\\n\\n&quot;.join(completed_sections)\n\n    return {&quot;final_report&quot;: completed_report_sections}\n\n\n# Conditional edge function to create llm_call workers that each write a section of the report\ndef assign_workers(state: State):\n    &quot;&quot;&quot;Assign a worker to each section in the plan&quot;&quot;&quot;\n\n    # Kick off section writing in parallel via Send() API\n    return [Send(&quot;llm_call&quot;, {&quot;section&quot;: s}) for s in state[&quot;sections&quot;]]\n\n\n# Build workflow\norchestrator_worker_builder = StateGraph(State)\n\n# Add the nodes\norchestrator_worker_builder.add_node(&quot;orchestrator&quot;, orchestrator)\norchestrator_worker_builder.add_node(&quot;llm_call&quot;, llm_call)\norchestrator_worker_builder.add_node(&quot;synthesizer&quot;, synthesizer)\n\n# Add edges to connect nodes\norchestrator_worker_builder.add_edge(START, &quot;orchestrator&quot;)\norchestrator_worker_builder.add_conditional_edges(\n    &quot;orchestrator&quot;, assign_workers, [&quot;llm_call&quot;]\n)\norchestrator_worker_builder.add_edge(&quot;llm_call&quot;, &quot;synthesizer&quot;)\norchestrator_worker_builder.add_edge(&quot;synthesizer&quot;, END)\n\n# Compile the workflow\norchestrator_worker = orchestrator_worker_builder.compile()\n\n# Show the workflow\ndisplay(Image(orchestrator_worker.get_graph().draw_mermaid_png()))\n\n# Invoke\nstate = orchestrator_worker.invoke({&quot;topic&quot;: &quot;Create a report on LLM scaling laws&quot;})\n\nfrom IPython.display import Markdown\nMarkdown(state[&quot;final_report&quot;])\n\nLangSmith Trace\nhttps://smith.langchain.com/public/78cbcfc3-38bf-471d-b62a-b299b144237d/r\nResources:\nLangChain Academy\nSee our lesson on orchestrator-worker here.\nExamples\nHere is a project that uses orchestrator-worker for report planning and writing. See our video here.\n\n\nfrom typing import List\n\n\n# Schema for structured output to use in planning\nclass Section(BaseModel):\n    name: str = Field(\n        description=&quot;Name for this section of the report.&quot;,\n    )\n    description: str = Field(\n        description=&quot;Brief overview of the main topics and concepts to be covered in this section.&quot;,\n    )\n\n\nclass Sections(BaseModel):\n    sections: List[Section] = Field(\n        description=&quot;Sections of the report.&quot;,\n    )\n\n\n# Augment the LLM with schema for structured output\nplanner = llm.with_structured_output(Sections)\n\n\n@task\ndef orchestrator(topic: str):\n    &quot;&quot;&quot;Orchestrator that generates a plan for the report&quot;&quot;&quot;\n    # Generate queries\n    report_sections = planner.invoke(\n        [\n            SystemMessage(content=&quot;Generate a plan for the report.&quot;),\n            HumanMessage(content=f&quot;Here is the report topic: {topic}&quot;),\n        ]\n    )\n\n    return report_sections.sections\n\n\n@task\ndef llm_call(section: Section):\n    &quot;&quot;&quot;Worker writes a section of the report&quot;&quot;&quot;\n\n    # Generate section\n    result = llm.invoke(\n        [\n            SystemMessage(content=&quot;Write a report section.&quot;),\n            HumanMessage(\n                content=f&quot;Here is the section name: {section.name} and description: {section.description}&quot;\n            ),\n        ]\n    )\n\n    # Write the updated section to completed sections\n    return result.content\n\n\n@task\ndef synthesizer(completed_sections: list[str]):\n    &quot;&quot;&quot;Synthesize full report from sections&quot;&quot;&quot;\n    final_report = &quot;\\n\\n---\\n\\n&quot;.join(completed_sections)\n    return final_report\n\n\n@entrypoint()\ndef orchestrator_worker(topic: str):\n    sections = orchestrator(topic).result()\n    section_futures = [llm_call(section) for section in sections]\n    final_report = synthesizer(\n        [section_fut.result() for section_fut in section_futures]\n    ).result()\n    return final_report\n\n# Invoke\nreport = orchestrator_worker.invoke(&quot;Create a report on LLM scaling laws&quot;)\nfrom IPython.display import Markdown\nMarkdown(report)\n\nLangSmith Trace\nhttps://smith.langchain.com/public/75a636d0-6179-4a12-9836-e0aa571e87c5/r\n\n\n\nEvaluator-optimizer¶\nIn the evaluator-optimizer workflow, one LLM call generates a response while another provides evaluation and feedback in a loop:\n\nWhen to use this workflow: This workflow is particularly effective when we have clear evaluation criteria, and when iterative refinement provides measurable value. The two signs of good fit are, first, that LLM responses can be demonstrably improved when a human articulates their feedback; and second, that the LLM can provide such feedback. This is analogous to the iterative writing process a human writer might go through when producing a polished document.\n\n\nGraph APIFunctional API\n\n\n# Graph state\nclass State(TypedDict):\n    joke: str\n    topic: str\n    feedback: str\n    funny_or_not: str\n\n\n# Schema for structured output to use in evaluation\nclass Feedback(BaseModel):\n    grade: Literal[&quot;funny&quot;, &quot;not funny&quot;] = Field(\n        description=&quot;Decide if the joke is funny or not.&quot;,\n    )\n    feedback: str = Field(\n        description=&quot;If the joke is not funny, provide feedback on how to improve it.&quot;,\n    )\n\n\n# Augment the LLM with schema for structured output\nevaluator = llm.with_structured_output(Feedback)\n\n\n# Nodes\ndef llm_call_generator(state: State):\n    &quot;&quot;&quot;LLM generates a joke&quot;&quot;&quot;\n\n    if state.get(&quot;feedback&quot;):\n        msg = llm.invoke(\n            f&quot;Write a joke about {state[\&#39;topic\&#39;]} but take into account the feedback: {state[\&#39;feedback\&#39;]}&quot;\n        )\n    else:\n        msg = llm.invoke(f&quot;Write a joke about {state[\&#39;topic\&#39;]}&quot;)\n    return {&quot;joke&quot;: msg.content}\n\n\ndef llm_call_evaluator(state: State):\n    &quot;&quot;&quot;LLM evaluates the joke&quot;&quot;&quot;\n\n    grade = evaluator.invoke(f&quot;Grade the joke {state[\&#39;joke\&#39;]}&quot;)\n    return {&quot;funny_or_not&quot;: grade.grade, &quot;feedback&quot;: grade.feedback}\n\n\n# Conditional edge function to route back to joke generator or end based upon feedback from the evaluator\ndef route_joke(state: State):\n    &quot;&quot;&quot;Route back to joke generator or end based upon feedback from the evaluator&quot;&quot;&quot;\n\n    if state[&quot;funny_or_not&quot;] == &quot;funny&quot;:\n        return &quot;Accepted&quot;\n    elif state[&quot;funny_or_not&quot;] == &quot;not funny&quot;:\n        return &quot;Rejected + Feedback&quot;\n\n\n# Build workflow\noptimizer_builder = StateGraph(State)\n\n# Add the nodes\noptimizer_builder.add_node(&quot;llm_call_generator&quot;, llm_call_generator)\noptimizer_builder.add_node(&quot;llm_call_evaluator&quot;, llm_call_evaluator)\n\n# Add edges to connect nodes\noptimizer_builder.add_edge(START, &quot;llm_call_generator&quot;)\noptimizer_builder.add_edge(&quot;llm_call_generator&quot;, &quot;llm_call_evaluator&quot;)\noptimizer_builder.add_conditional_edges(\n    &quot;llm_call_evaluator&quot;,\n    route_joke,\n    {  # Name returned by route_joke : Name of next node to visit\n        &quot;Accepted&quot;: END,\n        &quot;Rejected + Feedback&quot;: &quot;llm_call_generator&quot;,\n    },\n)\n\n# Compile the workflow\noptimizer_workflow = optimizer_builder.compile()\n\n# Show the workflow\ndisplay(Image(optimizer_workflow.get_graph().draw_mermaid_png()))\n\n# Invoke\nstate = optimizer_workflow.invoke({&quot;topic&quot;: &quot;Cats&quot;})\nprint(state[&quot;joke&quot;])\n\nLangSmith Trace\nhttps://smith.langchain.com/public/86ab3e60-2000-4bff-b988-9b89a3269789/r\nResources:\nExamples\nHere is an assistant that uses evaluator-optimizer to improve a report. See our video here.\nHere is a RAG workflow that grades answers for hallucinations or errors. See our video here.\n\n\n# Schema for structured output to use in evaluation\nclass Feedback(BaseModel):\n    grade: Literal[&quot;funny&quot;, &quot;not funny&quot;] = Field(\n        description=&quot;Decide if the joke is funny or not.&quot;,\n    )\n    feedback: str = Field(\n        description=&quot;If the joke is not funny, provide feedback on how to improve it.&quot;,\n    )\n\n\n# Augment the LLM with schema for structured output\nevaluator = llm.with_structured_output(Feedback)\n\n\n# Nodes\n@task\ndef llm_call_generator(topic: str, feedback: Feedback):\n    &quot;&quot;&quot;LLM generates a joke&quot;&quot;&quot;\n    if feedback:\n        msg = llm.invoke(\n            f&quot;Write a joke about {topic} but take into account the feedback: {feedback}&quot;\n        )\n    else:\n        msg = llm.invoke(f&quot;Write a joke about {topic}&quot;)\n    return msg.content\n\n\n@task\ndef llm_call_evaluator(joke: str):\n    &quot;&quot;&quot;LLM evaluates the joke&quot;&quot;&quot;\n    feedback = evaluator.invoke(f&quot;Grade the joke {joke}&quot;)\n    return feedback\n\n\n@entrypoint()\ndef optimizer_workflow(topic: str):\n    feedback = None\n    while True:\n        joke = llm_call_generator(topic, feedback).result()\n        feedback = llm_call_evaluator(joke).result()\n        if feedback.grade == &quot;funny&quot;:\n            break\n\n    return joke\n\n# Invoke\nfor step in optimizer_workflow.stream(&quot;Cats&quot;, stream_mode=&quot;updates&quot;):\n    print(step)\n    print(&quot;\\n&quot;)\n\nLangSmith Trace\nhttps://smith.langchain.com/public/f66830be-4339-4a6b-8a93-389ce5ae27b4/r\n\n\n\nAgent¶\nAgents are typically implemented as an LLM performing actions (via tool-calling) based on environmental feedback in a loop. As noted in the Anthropic blog on Building Effective Agents:\n\nAgents can handle sophisticated tasks, but their implementation is often straightforward. They are typically just LLMs using tools based on environmental feedback in a loop. It is therefore crucial to design toolsets and their documentation clearly and thoughtfully.\nWhen to use agents: Agents can be used for open-ended problems where it\&#39;s difficult or impossible to predict the required number of steps, and where you can\&#39;t hardcode a fixed path. The LLM will potentially operate for many turns, and you must have some level of trust in its decision-making. Agents\&#39; autonomy makes them ideal for scaling tasks in trusted environments.\n\n\nAPI Reference: tool\nfrom langchain_core.tools import tool\n\n\n# Define tools\n@tool\ndef multiply(a: int, b: int) -&gt; int:\n    &quot;&quot;&quot;Multiply a and b.\n\n    Args:\n        a: first int\n        b: second int\n    &quot;&quot;&quot;\n    return a * b\n\n\n@tool\ndef add(a: int, b: int) -&gt; int:\n    &quot;&quot;&quot;Adds a and b.\n\n    Args:\n        a: first int\n        b: second int\n    &quot;&quot;&quot;\n    return a + b\n\n\n@tool\ndef divide(a: int, b: int) -&gt; float:\n    &quot;&quot;&quot;Divide a and b.\n\n    Args:\n        a: first int\n        b: second int\n    &quot;&quot;&quot;\n    return a / b\n\n\n# Augment the LLM with tools\ntools = [add, multiply, divide]\ntools_by_name = {tool.name: tool for tool in tools}\nllm_with_tools = llm.bind_tools(tools)\n\nGraph APIFunctional API\n\n\nfrom langgraph.graph import MessagesState\nfrom langchain_core.messages import SystemMessage, HumanMessage, ToolMessage\n\n\n# Nodes\ndef llm_call(state: MessagesState):\n    &quot;&quot;&quot;LLM decides whether to call a tool or not&quot;&quot;&quot;\n\n    return {\n        &quot;messages&quot;: [\n            llm_with_tools.invoke(\n                [\n                    SystemMessage(\n                        content=&quot;You are a helpful assistant tasked with performing arithmetic on a set of inputs.&quot;\n                    )\n                ]\n                + state[&quot;messages&quot;]\n            )\n        ]\n    }\n\n\ndef tool_node(state: dict):\n    &quot;&quot;&quot;Performs the tool call&quot;&quot;&quot;\n\n    result = []\n    for tool_call in state[&quot;messages&quot;][-1].tool_calls:\n        tool = tools_by_name[tool_call[&quot;name&quot;]]\n        observation = tool.invoke(tool_call[&quot;args&quot;])\n        result.append(ToolMessage(content=observation, tool_call_id=tool_call[&quot;id&quot;]))\n    return {&quot;messages&quot;: result}\n\n\n# Conditional edge function to route to the tool node or end based upon whether the LLM made a tool call\ndef should_continue(state: MessagesState) -&gt; Literal[&quot;Action&quot;, END]:\n    &quot;&quot;&quot;Decide if we should continue the loop or stop based upon whether the LLM made a tool call&quot;&quot;&quot;\n\n    messages = state[&quot;messages&quot;]\n    last_message = messages[-1]\n    # If the LLM makes a tool call, then perform an action\n    if last_message.tool_calls:\n        return &quot;Action&quot;\n    # Otherwise, we stop (reply to the user)\n    return END\n\n\n# Build workflow\nagent_builder = StateGraph(MessagesState)\n\n# Add nodes\nagent_builder.add_node(&quot;llm_call&quot;, llm_call)\nagent_builder.add_node(&quot;environment&quot;, tool_node)\n\n# Add edges to connect nodes\nagent_builder.add_edge(START, &quot;llm_call&quot;)\nagent_builder.add_conditional_edges(\n    &quot;llm_call&quot;,\n    should_continue,\n    {\n        # Name returned by should_continue : Name of next node to visit\n        &quot;Action&quot;: &quot;environment&quot;,\n        END: END,\n    },\n)\nagent_builder.add_edge(&quot;environment&quot;, &quot;llm_call&quot;)\n\n# Compile the agent\nagent = agent_builder.compile()\n\n# Show the agent\ndisplay(Image(agent.get_graph(xray=True).draw_mermaid_png()))\n\n# Invoke\nmessages = [HumanMessage(content=&quot;Add 3 and 4.&quot;)]\nmessages = agent.invoke({&quot;messages&quot;: messages})\nfor m in messages[&quot;messages&quot;]:\n    m.pretty_print()\n\nLangSmith Trace\nhttps://smith.langchain.com/public/051f0391-6761-4f8c-a53b-22231b016690/r\nResources:\nLangChain Academy\nSee our lesson on agents here.\nExamples\nHere is a project that uses a tool calling agent to create / store long-term memories.\n\n\nfrom langgraph.graph import add_messages\nfrom langchain_core.messages import (\n    SystemMessage,\n    HumanMessage,\n    BaseMessage,\n    ToolCall,\n)\n\n\n@task\ndef call_llm(messages: list[BaseMessage]):\n    &quot;&quot;&quot;LLM decides whether to call a tool or not&quot;&quot;&quot;\n    return llm_with_tools.invoke(\n        [\n            SystemMessage(\n                content=&quot;You are a helpful assistant tasked with performing arithmetic on a set of inputs.&quot;\n            )\n        ]\n        + messages\n    )\n\n\n@task\ndef call_tool(tool_call: ToolCall):\n    &quot;&quot;&quot;Performs the tool call&quot;&quot;&quot;\n    tool = tools_by_name[tool_call[&quot;name&quot;]]\n    return tool.invoke(tool_call)\n\n\n@entrypoint()\ndef agent(messages: list[BaseMessage]):\n    llm_response = call_llm(messages).result()\n\n    while True:\n        if not llm_response.tool_calls:\n            break\n\n        # Execute tools\n        tool_result_futures = [\n            call_tool(tool_call) for tool_call in llm_response.tool_calls\n        ]\n        tool_results = [fut.result() for fut in tool_result_futures]\n        messages = add_messages(messages, [llm_response, *tool_results])\n        llm_response = call_llm(messages).result()\n\n    messages = add_messages(messages, llm_response)\n    return messages\n\n# Invoke\nmessages = [HumanMessage(content=&quot;Add 3 and 4.&quot;)]\nfor chunk in agent.stream(messages, stream_mode=&quot;updates&quot;):\n    print(chunk)\n    print(&quot;\\n&quot;)\n\nLangSmith Trace\nhttps://smith.langchain.com/public/42ae8bf9-3935-4504-a081-8ddbcbfc8b2e/r\n\n\n\nPre-built¶\nLangGraph also provides a pre-built method for creating an agent as defined above (using the create_react_agent function):\nhttps://langchain-ai.github.io/langgraph/how-tos/create-react-agent/\nAPI Reference: create_react_agent\nfrom langgraph.prebuilt import create_react_agent\n\n# Pass in:\n# (1) the augmented LLM with tools\n# (2) the tools list (which is used to create the tool node)\npre_built_agent = create_react_agent(llm, tools=tools)\n\n# Show the agent\ndisplay(Image(pre_built_agent.get_graph().draw_mermaid_png()))\n\n# Invoke\nmessages = [HumanMessage(content=&quot;Add 3 and 4.&quot;)]\nmessages = pre_built_agent.invoke({&quot;messages&quot;: messages})\nfor m in messages[&quot;messages&quot;]:\n    m.pretty_print()\n\nLangSmith Trace\nhttps://smith.langchain.com/public/abab6a44-29f6-4b97-8164-af77413e494d/r\nWhat LangGraph provides¶\nBy constructing each of the above in LangGraph, we get a few things:\nPersistence: Human-in-the-Loop¶\nLangGraph persistence layer supports interruption and approval of actions (e.g., Human In The Loop). See Module 3 of LangChain Academy.\nPersistence: Memory¶\nLangGraph persistence layer supports conversational (short-term) memory and long-term memory. See Modules 2 and 5 of LangChain Academy:\nStreaming¶\nLangGraph provides several ways to stream workflow / agent outputs or intermediate state. See Module 3 of LangChain Academy.\nDeployment¶\nLangGraph provides an easy on-ramp for deployment, observability, and evaluation. See module 6 of LangChain Academy.\n\n\n\n\n\n\n\n  Back to top\n\n\n\n\n\n\n\n\n\n\n                Previous\n              \n\n                Run a local server\n              \n\n\n\n\n\n                Next\n              \n\n                Agent architectures\n              \n\n\n\n\n\n\n\n\n\n\n      Copyright © 2025 LangChain, Inc | Consent Preferences\n\n  \n  \n    Made with\n    \n      Material for MkDocs\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&#39;)],
 [Document(metadata={&#39;source&#39;: &#39;https://langchain-ai.github.io/langgraph/how-tos/map-reduce/&#39;, &#39;title&#39;: &#39;Redirecting...&#39;, &#39;language&#39;: &#39;en&#39;}, page_content=&#39;\n\n\n\n\nRedirecting...\n\n\n\n\n\n\nRedirecting...\n\n\n&#39;)]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">docs_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">docs</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

<span class="n">text_splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="p">(</span>
    <span class="n">chunk_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">100</span>
<span class="p">)</span>

<span class="n">doc_splits</span> <span class="o">=</span> <span class="n">text_splitter</span><span class="o">.</span><span class="n">split_documents</span><span class="p">(</span><span class="n">docs_list</span><span class="p">)</span>

<span class="c1">## Add alll these text to vectordb</span>

<span class="n">vectorstore</span><span class="o">=</span><span class="n">FAISS</span><span class="o">.</span><span class="n">from_documents</span><span class="p">(</span>
    <span class="n">documents</span><span class="o">=</span><span class="n">doc_splits</span><span class="p">,</span>
    <span class="n">embedding</span><span class="o">=</span><span class="n">OpenAIEmbeddings</span><span class="p">()</span>
<span class="p">)</span>


<span class="n">retriever</span><span class="o">=</span><span class="n">vectorstore</span><span class="o">.</span><span class="n">as_retriever</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">retriever</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="s2">&quot;what is langgraph&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Document(id=&#39;8baf3ffc-c99c-4c35-802a-dceb270668e8&#39;, metadata={&#39;source&#39;: &#39;https://langchain-ai.github.io/langgraph/tutorials/workflows/&#39;, &#39;title&#39;: &#39;Workflows &amp; agents&#39;, &#39;description&#39;: &#39;Build reliable, stateful AI systems, without giving up control&#39;, &#39;language&#39;: &#39;en&#39;}, page_content=&#39;LangSmith Trace\nhttps://smith.langchain.com/public/abab6a44-29f6-4b97-8164-af77413e494d/r\nWhat LangGraph provides¶\nBy constructing each of the above in LangGraph, we get a few things:\nPersistence: Human-in-the-Loop¶\nLangGraph persistence layer supports interruption and approval of actions (e.g., Human In The Loop). See Module 3 of LangChain Academy.\nPersistence: Memory¶\nLangGraph persistence layer supports conversational (short-term) memory and long-term memory. See Modules 2 and 5 of LangChain Academy:\nStreaming¶\nLangGraph provides several ways to stream workflow / agent outputs or intermediate state. See Module 3 of LangChain Academy.\nDeployment¶\nLangGraph provides an easy on-ramp for deployment, observability, and evaluation. See module 6 of LangChain Academy.\n\n\n\n\n\n\n\n  Back to top\n\n\n\n\n\n\n\n\n\n\n                Previous\n              \n\n                Run a local server\n              \n\n\n\n\n\n                Next\n              \n\n                Agent architectures&#39;),
 Document(id=&#39;8c7d0f29-7628-4c12-96b4-5f51c372aaf9&#39;, metadata={&#39;source&#39;: &#39;https://langchain-ai.github.io/langgraph/tutorials/workflows/&#39;, &#39;title&#39;: &#39;Workflows &amp; agents&#39;, &#39;description&#39;: &#39;Build reliable, stateful AI systems, without giving up control&#39;, &#39;language&#39;: &#39;en&#39;}, page_content=&#39;LangSmith Trace\nhttps://smith.langchain.com/public/42ae8bf9-3935-4504-a081-8ddbcbfc8b2e/r\n\n\n\nPre-built¶\nLangGraph also provides a pre-built method for creating an agent as defined above (using the create_react_agent function):\nhttps://langchain-ai.github.io/langgraph/how-tos/create-react-agent/\nAPI Reference: create_react_agent\nfrom langgraph.prebuilt import create_react_agent\n\n# Pass in:\n# (1) the augmented LLM with tools\n# (2) the tools list (which is used to create the tool node)\npre_built_agent = create_react_agent(llm, tools=tools)\n\n# Show the agent\ndisplay(Image(pre_built_agent.get_graph().draw_mermaid_png()))\n\n# Invoke\nmessages = [HumanMessage(content=&quot;Add 3 and 4.&quot;)]\nmessages = pre_built_agent.invoke({&quot;messages&quot;: messages})\nfor m in messages[&quot;messages&quot;]:\n    m.pretty_print()&#39;),
 Document(id=&#39;7492c585-5f26-4506-801f-1efcc4bdc929&#39;, metadata={&#39;source&#39;: &#39;https://langchain-ai.github.io/langgraph/tutorials/workflows/&#39;, &#39;title&#39;: &#39;Workflows &amp; agents&#39;, &#39;description&#39;: &#39;Build reliable, stateful AI systems, without giving up control&#39;, &#39;language&#39;: &#39;en&#39;}, page_content=&#39;LangSmith Trace\nhttps://smith.langchain.com/public/332fa4fc-b6ca-416e-baa3-161625e69163/r\n\n\n\nParallelization¶\nWith parallelization, LLMs work simultaneously on a task:\n\nLLMs can sometimes work simultaneously on a task and have their outputs aggregated programmatically. This workflow, parallelization, manifests in two key variations: Sectioning: Breaking a task into independent subtasks run in parallel. Voting: Running the same task multiple times to get diverse outputs.\nWhen to use this workflow: Parallelization is effective when the divided subtasks can be parallelized for speed, or when multiple perspectives or attempts are needed for higher confidence results. For complex tasks with multiple considerations, LLMs generally perform better when each consideration is handled by a separate LLM call, allowing focused attention on each specific aspect.\n\n\nGraph APIFunctional API&#39;),
 Document(id=&#39;204ff80a-30b3-4213-b095-48fe699e914c&#39;, metadata={&#39;source&#39;: &#39;https://langchain-ai.github.io/langgraph/tutorials/workflows/&#39;, &#39;title&#39;: &#39;Workflows &amp; agents&#39;, &#39;description&#39;: &#39;Build reliable, stateful AI systems, without giving up control&#39;, &#39;language&#39;: &#39;en&#39;}, page_content=&#39;Workflows are systems where LLMs and tools are orchestrated through predefined code paths.\nAgents, on the other hand, are systems where LLMs dynamically direct their own processes and tool usage, maintaining control over how they accomplish tasks.\n\nHere is a simple way to visualize these differences:\n\nWhen building agents and workflows, LangGraph offers a number of benefits including persistence, streaming, and support for debugging as well as deployment.\nSet up¶\nYou can use any chat model that supports structured outputs and tool calling. Below, we show the process of installing the packages, setting API keys, and testing structured outputs / tool calling for Anthropic.\n\nInstall dependencies\npip install langchain_core langchain-anthropic langgraph\n\n\nInitialize an LLM\nAPI Reference: ChatAnthropic\nimport os\nimport getpass\n\nfrom langchain_anthropic import ChatAnthropic\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f&quot;{var}: &quot;)&#39;)]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">langchain_core.tools.retriever</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_retriever_tool</span>

<span class="c1"># assume you already have a retriever, e.g., from a vector store</span>
<span class="n">retriever_tool</span> <span class="o">=</span> <span class="n">create_retriever_tool</span><span class="p">(</span>
    <span class="n">retriever</span><span class="o">=</span><span class="n">retriever</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;retriever_vector_db_blog&quot;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Search and retrieve information about LangGraph.&quot;</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Retriever tool created successfully!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Retriever tool created successfully!
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">retriever_tool</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Tool(name=&#39;retriever_vector_db_blog&#39;, description=&#39;Search and retrieve information about LangGraph.&#39;, args_schema=&lt;class &#39;langchain_core.tools.retriever.RetrieverInput&#39;&gt;, func=functools.partial(&lt;function _get_relevant_documents at 0x00000112B1628400&gt;, retriever=VectorStoreRetriever(tags=[&#39;FAISS&#39;, &#39;OpenAIEmbeddings&#39;], vectorstore=&lt;langchain_community.vectorstores.faiss.FAISS object at 0x00000112B1539760&gt;, search_kwargs={}), document_prompt=PromptTemplate(input_variables=[&#39;page_content&#39;], input_types={}, partial_variables={}, template=&#39;{page_content}&#39;), document_separator=&#39;\n\n&#39;, response_format=&#39;content&#39;), coroutine=functools.partial(&lt;function _aget_relevant_documents at 0x00000112B15468E0&gt;, retriever=VectorStoreRetriever(tags=[&#39;FAISS&#39;, &#39;OpenAIEmbeddings&#39;], vectorstore=&lt;langchain_community.vectorstores.faiss.FAISS object at 0x00000112B1539760&gt;, search_kwargs={}), document_prompt=PromptTemplate(input_variables=[&#39;page_content&#39;], input_types={}, partial_variables={}, template=&#39;{page_content}&#39;), document_separator=&#39;\n\n&#39;, response_format=&#39;content&#39;))
</pre></div>
</div>
</div>
</div>
</section>
<section id="langchain-blogs-seperate-vector-store">
<h1>Langchain Blogs- Seperate Vector Store<a class="headerlink" href="#langchain-blogs-seperate-vector-store" title="Link to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">langchain_urls</span><span class="o">=</span><span class="p">[</span>
    <span class="s2">&quot;https://python.langchain.com/docs/tutorials/&quot;</span><span class="p">,</span>
    <span class="s2">&quot;https://python.langchain.com/docs/tutorials/chatbot/&quot;</span><span class="p">,</span>
    <span class="s2">&quot;https://python.langchain.com/docs/tutorials/qa_chat_history/&quot;</span>
<span class="p">]</span>

<span class="n">docs</span><span class="o">=</span><span class="p">[</span><span class="n">WebBaseLoader</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">langchain_urls</span><span class="p">]</span>
<span class="n">docs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[Document(metadata={&#39;source&#39;: &#39;https://python.langchain.com/docs/tutorials/&#39;, &#39;title&#39;: &#39;index | 🦜️🔗 LangChain&#39;, &#39;description&#39;: &#39;⚠️ THESE DOCS ARE OUTDATED. Visit the new v1.0 docs&#39;, &#39;language&#39;: &#39;en&#39;}, page_content=&#39;\n\n\n\n\nindex | 🦜️🔗 LangChain\n\n\n\n\n\n\n\n\nSkip to main content⚠️ THESE DOCS ARE OUTDATED. Visit the new v1.0 docsIntegrationsAPI ReferenceMoreContributingPeopleError referenceLangSmithLangGraphLangChain HubLangChain JS/TSv0.3v0.3v0.2v0.1💬SearchIntroductionTutorialsBuild a Question Answering application over a Graph DatabaseindexBuild a simple LLM application with chat models and prompt templatesBuild a ChatbotBuild a Retrieval Augmented Generation (RAG) App: Part 2Build an Extraction ChainBuild an AgentTaggingBuild a Retrieval Augmented Generation (RAG) App: Part 1Build a semantic search engineBuild a Question/Answering system over SQL dataSummarize TextHow-to guidesindexHow to use tools in a chainHow to use a vectorstore as a retrieverHow to add memory to chatbotsHow to use example selectorsHow to add a semantic layer over graph databaseHow to invoke runnables in parallelHow to stream chat model responsesHow to add default invocation args to a RunnableHow to add retrieval to chatbotsHow to use few shot examples in chat modelsHow to do tool/function callingHow to install LangChain packagesHow to add examples to the prompt for query analysisHow to use few shot examplesHow to run custom functionsHow to use output parsers to parse an LLM response into structured formatHow to handle cases where no queries are generatedHow to route between sub-chainsHow to return structured data from a modelHow to summarize text through parallelizationHow to summarize text through iterative refinementHow to summarize text in a single LLM callHow to use toolkitsHow to add ad-hoc tool calling capability to LLMs and Chat ModelsBuild an Agent with AgentExecutor (Legacy)How to construct knowledge graphsHow to partially format prompt templatesHow to handle multiple queries when doing query analysisHow to use built-in tools and toolkitsHow to pass through arguments from one step to the nextHow to compose prompts togetherHow to handle multiple retrievers when doing query analysisHow to add values to a chain\&#39;s stateHow to construct filters for query analysisHow to configure runtime chain internalsHow to deal with high-cardinality categoricals when doing query analysisCustom Document LoaderHow to use the MultiQueryRetrieverHow to add scores to retriever resultsCachingHow to use callbacks in async environmentsHow to attach callbacks to a runnableHow to propagate callbacks  constructorHow to dispatch custom callback eventsHow to pass callbacks in at runtimeHow to split by characterHow to cache chat model responsesHow to handle rate limitsHow to init any model in one lineHow to track token usage in ChatModelsHow to add tools to chatbotsHow to split codeHow to do retrieval with contextual compressionHow to convert Runnables to ToolsHow to create custom callback handlersHow to create a custom chat model classCustom EmbeddingsHow to create a custom LLM classCustom RetrieverHow to create toolsHow to debug your LLM appsHow to load CSVsHow to load documents from a directoryHow to load HTMLHow to load JSONHow to load MarkdownHow to load Microsoft Office filesHow to load PDFsHow to load web pagesHow to create a dynamic (self-constructing) chainText embedding modelsHow to combine results from multiple retrieversHow to select examples from a LangSmith datasetHow to select examples by lengthHow to select examples by maximal marginal relevance (MMR)How to select examples by n-gram overlapHow to select examples by similarityHow to use reference examples when doing extractionHow to handle long text when doing extractionHow to use prompting alone (no tool calling) to do extractionHow to add fallbacks to a runnableHow to filter messagesHybrid SearchHow to use the LangChain indexing APIHow to inspect runnablesLangChain Expression Language CheatsheetHow to cache LLM responsesHow to track token usage for LLMsRun models locallyHow to get log probabilitiesHow to reorder retrieved results to mitigate the &quot;lost in the middle&quot; effectHow to split Markdown by HeadersHow to merge consecutive messages of the same typeHow to add message historyHow to migrate from legacy LangChain agents to LangGraphHow to retrieve using multiple vectors per documentHow to pass multimodal data to modelsHow to use multimodal promptsHow to create a custom Output ParserHow to use the output-fixing parserHow to parse JSON outputHow to retry when a parsing error occursHow to parse text from message objectsHow to parse XML outputHow to parse YAML outputHow to use the Parent Document RetrieverHow to use LangChain with different Pydantic versionsHow to add chat historyHow to get a RAG application to add citationsHow to do per-user retrievalHow to get your RAG application to return sourcesHow to stream results from your RAG applicationHow to split JSON dataHow to recursively split text by charactersResponse metadataHow to pass runtime secrets to runnablesHow to do &quot;self-querying&quot; retrievalHow to split text based on semantic similarityHow to chain runnablesHow to save and load LangChain objectsHow to split text by tokensHow to split HTMLHow to do question answering over CSVsHow to deal with large databases when doing SQL question-answeringHow to better prompt when doing SQL question-answeringHow to do query validation as part of SQL question-answeringHow to stream runnablesHow to stream responses from an LLMHow to use a time-weighted vector store retrieverHow to return artifacts from a toolHow to use chat models to call toolsHow to disable parallel tool callingHow to force models to call a toolHow to access the RunnableConfig from a toolHow to pass tool outputs to chat modelsHow to pass run time values to toolsHow to stream events from a toolHow to stream tool callsHow to convert tools to OpenAI FunctionsHow to handle tool errorsHow to use few-shot prompting with tool callingHow to add a human-in-the-loop for toolsHow to bind model-specific toolsHow to trim messagesHow to create and query vector storesConceptual guideAgentsArchitectureAsync programming with LangChainCallbacksChat historyChat modelsDocument loadersEmbedding modelsEvaluationExample selectorsFew-shot promptingindexKey-value storesLangChain Expression Language (LCEL)MessagesMultimodalityOutput parsersPrompt TemplatesRetrieval augmented generation (RAG)RetrievalRetrieversRunnable interfaceStreamingStructured outputsTestingString-in, string-out llmsText splittersTokensTool callingToolsTracingVector storesWhy LangChain?Ecosystem🦜🛠️ LangSmith🦜🕸️ LangGraphVersionsv0.3v0.2Pydantic compatibilityMigrating from v0.0 chainsHow to migrate from v0.0 chainsMigrating from ConstitutionalChainMigrating from ConversationalChainMigrating from ConversationalRetrievalChainMigrating from LLMChainMigrating from LLMMathChainMigrating from LLMRouterChainMigrating from MapReduceDocumentsChainMigrating from MapRerankDocumentsChainMigrating from MultiPromptChainMigrating from RefineDocumentsChainMigrating from RetrievalQAMigrating from StuffDocumentsChainUpgrading to LangGraph memoryHow to migrate to LangGraph memoryHow to use BaseChatMessageHistory with LangGraphMigrating off ConversationBufferMemory or ConversationStringBufferMemoryMigrating off ConversationBufferWindowMemory or ConversationTokenBufferMemoryMigrating off ConversationSummaryMemory or ConversationSummaryBufferMemoryA Long-Term Memory AgentRelease policySecurity PolicyTutorialsOn this pagedanger⚠️ THESE DOCS ARE OUTDATED. Visit the new v1.0 docs\nTutorials\nNew to LangChain or LLM app development in general? Read this material to quickly get up and running building your first applications.\nGet started\u200b\nFamiliarize yourself with LangChain\&#39;s open-source components by building simple applications.\nIf you\&#39;re looking to get started with chat models, vector stores,\nor other LangChain components from a specific provider, check out our supported integrations.\n\nChat models and prompts: Build a simple LLM application with prompt templates and chat models.\nSemantic search: Build a semantic search engine over a PDF with document loaders, embedding models, and vector stores.\nClassification: Classify text into categories or labels using chat models with structured outputs.\nExtraction: Extract structured data from text and other unstructured media using chat models and few-shot examples.\n\nRefer to the how-to guides for more detail on using all LangChain components.\nOrchestration\u200b\nGet started using LangGraph to assemble LangChain components into full-featured applications.\n\nChatbots: Build a chatbot that incorporates memory.\nAgents: Build an agent that interacts with external tools.\nRetrieval Augmented Generation (RAG) Part 1: Build an application that uses your own documents to inform its responses.\nRetrieval Augmented Generation (RAG) Part 2: Build a RAG application that incorporates a memory of its user interactions and multi-step retrieval.\nQuestion-Answering with SQL: Build a question-answering system that executes SQL queries to inform its responses.\nSummarization: Generate summaries of (potentially long) texts.\nQuestion-Answering with Graph Databases: Build a question-answering system that queries a graph database to inform its responses.\n\nLangSmith\u200b\nLangSmith allows you to closely trace, monitor and evaluate your LLM application.\nIt seamlessly integrates with LangChain, and you can use it to inspect and debug individual steps of your chains as you build.\nLangSmith documentation is hosted on a separate site.\nYou can peruse LangSmith tutorials here.\nEvaluation\u200b\nLangSmith helps you evaluate the performance of your LLM applications. The tutorial below is a great way to get started:\n\nEvaluate your LLM application\nEdit this pagePreviousIntroductionNextBuild a Question Answering application over a Graph DatabaseGet startedOrchestrationLangSmithEvaluationCommunityLangChain ForumTwitterSlackGitHubOrganizationPythonJS/TSMoreHomepageBlogYouTubeCopyright © 2025 LangChain, Inc.\n\n&#39;)],
 [Document(metadata={&#39;source&#39;: &#39;https://python.langchain.com/docs/tutorials/chatbot/&#39;, &#39;title&#39;: &#39;Build a Chatbot | 🦜️🔗 LangChain&#39;, &#39;description&#39;: &#39;This tutorial previously used the RunnableWithMessageHistory abstraction. You can access that version of the documentation in the v0.2 docs.&#39;, &#39;language&#39;: &#39;en&#39;}, page_content=&#39;\n\n\n\n\nBuild a Chatbot | 🦜️🔗 LangChain\n\n\n\n\n\n\n\n\nSkip to main content⚠️ THESE DOCS ARE OUTDATED. Visit the new v1.0 docsIntegrationsAPI ReferenceMoreContributingPeopleError referenceLangSmithLangGraphLangChain HubLangChain JS/TSv0.3v0.3v0.2v0.1💬SearchIntroductionTutorialsBuild a Question Answering application over a Graph DatabaseindexBuild a simple LLM application with chat models and prompt templatesBuild a ChatbotBuild a Retrieval Augmented Generation (RAG) App: Part 2Build an Extraction ChainBuild an AgentTaggingBuild a Retrieval Augmented Generation (RAG) App: Part 1Build a semantic search engineBuild a Question/Answering system over SQL dataSummarize TextHow-to guidesindexHow to use tools in a chainHow to use a vectorstore as a retrieverHow to add memory to chatbotsHow to use example selectorsHow to add a semantic layer over graph databaseHow to invoke runnables in parallelHow to stream chat model responsesHow to add default invocation args to a RunnableHow to add retrieval to chatbotsHow to use few shot examples in chat modelsHow to do tool/function callingHow to install LangChain packagesHow to add examples to the prompt for query analysisHow to use few shot examplesHow to run custom functionsHow to use output parsers to parse an LLM response into structured formatHow to handle cases where no queries are generatedHow to route between sub-chainsHow to return structured data from a modelHow to summarize text through parallelizationHow to summarize text through iterative refinementHow to summarize text in a single LLM callHow to use toolkitsHow to add ad-hoc tool calling capability to LLMs and Chat ModelsBuild an Agent with AgentExecutor (Legacy)How to construct knowledge graphsHow to partially format prompt templatesHow to handle multiple queries when doing query analysisHow to use built-in tools and toolkitsHow to pass through arguments from one step to the nextHow to compose prompts togetherHow to handle multiple retrievers when doing query analysisHow to add values to a chain\&#39;s stateHow to construct filters for query analysisHow to configure runtime chain internalsHow to deal with high-cardinality categoricals when doing query analysisCustom Document LoaderHow to use the MultiQueryRetrieverHow to add scores to retriever resultsCachingHow to use callbacks in async environmentsHow to attach callbacks to a runnableHow to propagate callbacks  constructorHow to dispatch custom callback eventsHow to pass callbacks in at runtimeHow to split by characterHow to cache chat model responsesHow to handle rate limitsHow to init any model in one lineHow to track token usage in ChatModelsHow to add tools to chatbotsHow to split codeHow to do retrieval with contextual compressionHow to convert Runnables to ToolsHow to create custom callback handlersHow to create a custom chat model classCustom EmbeddingsHow to create a custom LLM classCustom RetrieverHow to create toolsHow to debug your LLM appsHow to load CSVsHow to load documents from a directoryHow to load HTMLHow to load JSONHow to load MarkdownHow to load Microsoft Office filesHow to load PDFsHow to load web pagesHow to create a dynamic (self-constructing) chainText embedding modelsHow to combine results from multiple retrieversHow to select examples from a LangSmith datasetHow to select examples by lengthHow to select examples by maximal marginal relevance (MMR)How to select examples by n-gram overlapHow to select examples by similarityHow to use reference examples when doing extractionHow to handle long text when doing extractionHow to use prompting alone (no tool calling) to do extractionHow to add fallbacks to a runnableHow to filter messagesHybrid SearchHow to use the LangChain indexing APIHow to inspect runnablesLangChain Expression Language CheatsheetHow to cache LLM responsesHow to track token usage for LLMsRun models locallyHow to get log probabilitiesHow to reorder retrieved results to mitigate the &quot;lost in the middle&quot; effectHow to split Markdown by HeadersHow to merge consecutive messages of the same typeHow to add message historyHow to migrate from legacy LangChain agents to LangGraphHow to retrieve using multiple vectors per documentHow to pass multimodal data to modelsHow to use multimodal promptsHow to create a custom Output ParserHow to use the output-fixing parserHow to parse JSON outputHow to retry when a parsing error occursHow to parse text from message objectsHow to parse XML outputHow to parse YAML outputHow to use the Parent Document RetrieverHow to use LangChain with different Pydantic versionsHow to add chat historyHow to get a RAG application to add citationsHow to do per-user retrievalHow to get your RAG application to return sourcesHow to stream results from your RAG applicationHow to split JSON dataHow to recursively split text by charactersResponse metadataHow to pass runtime secrets to runnablesHow to do &quot;self-querying&quot; retrievalHow to split text based on semantic similarityHow to chain runnablesHow to save and load LangChain objectsHow to split text by tokensHow to split HTMLHow to do question answering over CSVsHow to deal with large databases when doing SQL question-answeringHow to better prompt when doing SQL question-answeringHow to do query validation as part of SQL question-answeringHow to stream runnablesHow to stream responses from an LLMHow to use a time-weighted vector store retrieverHow to return artifacts from a toolHow to use chat models to call toolsHow to disable parallel tool callingHow to force models to call a toolHow to access the RunnableConfig from a toolHow to pass tool outputs to chat modelsHow to pass run time values to toolsHow to stream events from a toolHow to stream tool callsHow to convert tools to OpenAI FunctionsHow to handle tool errorsHow to use few-shot prompting with tool callingHow to add a human-in-the-loop for toolsHow to bind model-specific toolsHow to trim messagesHow to create and query vector storesConceptual guideAgentsArchitectureAsync programming with LangChainCallbacksChat historyChat modelsDocument loadersEmbedding modelsEvaluationExample selectorsFew-shot promptingindexKey-value storesLangChain Expression Language (LCEL)MessagesMultimodalityOutput parsersPrompt TemplatesRetrieval augmented generation (RAG)RetrievalRetrieversRunnable interfaceStreamingStructured outputsTestingString-in, string-out llmsText splittersTokensTool callingToolsTracingVector storesWhy LangChain?Ecosystem🦜🛠️ LangSmith🦜🕸️ LangGraphVersionsv0.3v0.2Pydantic compatibilityMigrating from v0.0 chainsHow to migrate from v0.0 chainsMigrating from ConstitutionalChainMigrating from ConversationalChainMigrating from ConversationalRetrievalChainMigrating from LLMChainMigrating from LLMMathChainMigrating from LLMRouterChainMigrating from MapReduceDocumentsChainMigrating from MapRerankDocumentsChainMigrating from MultiPromptChainMigrating from RefineDocumentsChainMigrating from RetrievalQAMigrating from StuffDocumentsChainUpgrading to LangGraph memoryHow to migrate to LangGraph memoryHow to use BaseChatMessageHistory with LangGraphMigrating off ConversationBufferMemory or ConversationStringBufferMemoryMigrating off ConversationBufferWindowMemory or ConversationTokenBufferMemoryMigrating off ConversationSummaryMemory or ConversationSummaryBufferMemoryA Long-Term Memory AgentRelease policySecurity PolicyTutorialsBuild a ChatbotOn this pageBuild a Chatbot\nnoteThis tutorial previously used the RunnableWithMessageHistory abstraction. You can access that version of the documentation in the v0.2 docs.As of the v0.3 release of LangChain, we recommend that LangChain users take advantage of LangGraph persistence to incorporate memory into new LangChain applications.If your code is already relying on RunnableWithMessageHistory or BaseChatMessageHistory, you do not need to make any changes. We do not plan on deprecating this functionality in the near future as it works for simple chat applications and any code that uses RunnableWithMessageHistory will continue to work as expected.Please see How to migrate to LangGraph Memory for more details.\nOverview\u200b\nWe\&#39;ll go over an example of how to design and implement an LLM-powered chatbot.\nThis chatbot will be able to have a conversation and remember previous interactions with a chat model.\nNote that this chatbot that we build will only use the language model to have a conversation.\nThere are several other related concepts that you may be looking for:\n\nConversational RAG: Enable a chatbot experience over an external source of data\nAgents: Build a chatbot that can take actions\n\nThis tutorial will cover the basics which will be helpful for those two more advanced topics, but feel free to skip directly to there should you choose.\nSetup\u200b\nJupyter Notebook\u200b\nThis guide (and most of the other guides in the documentation) uses Jupyter notebooks and assumes the reader is as well. Jupyter notebooks are perfect for learning how to work with LLM systems because oftentimes things can go wrong (unexpected output, API down, etc) and going through guides in an interactive environment is a great way to better understand them.\nThis and other tutorials are perhaps most conveniently run in a Jupyter notebook. See here for instructions on how to install.\nInstallation\u200b\nFor this tutorial we will need langchain-core and langgraph. This guide requires langgraph &gt;= 0.2.28.\n\nPipCondapip install langchain-core langgraph&gt;0.2.27conda install langchain-core langgraph&gt;0.2.27 -c conda-forge\nFor more details, see our Installation guide.\nLangSmith\u200b\nMany of the applications you build with LangChain will contain multiple steps with multiple invocations of LLM calls.\nAs these applications get more and more complex, it becomes crucial to be able to inspect what exactly is going on inside your chain or agent.\nThe best way to do this is with LangSmith.\nAfter you sign up at the link above, (you\&#39;ll need to create an API key from the Settings -&gt; API Keys page on the LangSmith website), make sure to set your environment variables to start logging traces:\nexport LANGSMITH_TRACING=&quot;true&quot;export LANGSMITH_API_KEY=&quot;...&quot;\nOr, if in a notebook, you can set them with:\nimport getpassimport osos.environ[&quot;LANGSMITH_TRACING&quot;] = &quot;true&quot;os.environ[&quot;LANGSMITH_API_KEY&quot;] = getpass.getpass()\nQuickstart\u200b\nFirst up, let\&#39;s learn how to use a language model by itself. LangChain supports many different language models that you can use interchangeably - select the one you want to use below!\n\nSelect chat model:Google Gemini▾OpenAIAnthropicAzureGoogle GeminiGoogle VertexAWSGroqCohereNVIDIAFireworks AIMistral AITogether AIIBM watsonxDatabricksxAIPerplexityDeepSeekChatOCIGenAIpip install -qU &quot;langchain[google-genai]&quot;import getpassimport osif not os.environ.get(&quot;GOOGLE_API_KEY&quot;):  os.environ[&quot;GOOGLE_API_KEY&quot;] = getpass.getpass(&quot;Enter API key for Google Gemini: &quot;)from langchain.chat_models import init_chat_modelmodel = init_chat_model(&quot;gemini-2.5-flash&quot;, model_provider=&quot;google_genai&quot;)\nLet\&#39;s first use the model directly. ChatModels are instances of LangChain &quot;Runnables&quot;, which means they expose a standard interface for interacting with them. To just simply call the model, we can pass in a list of messages to the .invoke method.\nfrom langchain_core.messages import HumanMessagemodel.invoke([HumanMessage(content=&quot;Hi! I\&#39;m Bob&quot;)])API Reference:HumanMessage\nAIMessage(content=\&#39;Hi Bob! How can I assist you today?\&#39;, additional_kwargs={\&#39;refusal\&#39;: None}, response_metadata={\&#39;token_usage\&#39;: {\&#39;completion_tokens\&#39;: 10, \&#39;prompt_tokens\&#39;: 11, \&#39;total_tokens\&#39;: 21, \&#39;completion_tokens_details\&#39;: {\&#39;accepted_prediction_tokens\&#39;: 0, \&#39;audio_tokens\&#39;: 0, \&#39;reasoning_tokens\&#39;: 0, \&#39;rejected_prediction_tokens\&#39;: 0}, \&#39;prompt_tokens_details\&#39;: {\&#39;audio_tokens\&#39;: 0, \&#39;cached_tokens\&#39;: 0}}, \&#39;model_name\&#39;: \&#39;gpt-4o-mini-2024-07-18\&#39;, \&#39;system_fingerprint\&#39;: \&#39;fp_0705bf87c0\&#39;, \&#39;finish_reason\&#39;: \&#39;stop\&#39;, \&#39;logprobs\&#39;: None}, id=\&#39;run-5211544f-da9f-4325-8b8e-b3d92b2fc71a-0\&#39;, usage_metadata={\&#39;input_tokens\&#39;: 11, \&#39;output_tokens\&#39;: 10, \&#39;total_tokens\&#39;: 21, \&#39;input_token_details\&#39;: {\&#39;audio\&#39;: 0, \&#39;cache_read\&#39;: 0}, \&#39;output_token_details\&#39;: {\&#39;audio\&#39;: 0, \&#39;reasoning\&#39;: 0}})\nThe model on its own does not have any concept of state. For example, if you ask a followup question:\nmodel.invoke([HumanMessage(content=&quot;What\&#39;s my name?&quot;)])\nAIMessage(content=&quot;I\&#39;m sorry, but I don\&#39;t have access to personal information about users unless it has been shared with me in the course of our conversation. How can I assist you today?&quot;, additional_kwargs={\&#39;refusal\&#39;: None}, response_metadata={\&#39;token_usage\&#39;: {\&#39;completion_tokens\&#39;: 34, \&#39;prompt_tokens\&#39;: 11, \&#39;total_tokens\&#39;: 45, \&#39;completion_tokens_details\&#39;: {\&#39;accepted_prediction_tokens\&#39;: 0, \&#39;audio_tokens\&#39;: 0, \&#39;reasoning_tokens\&#39;: 0, \&#39;rejected_prediction_tokens\&#39;: 0}, \&#39;prompt_tokens_details\&#39;: {\&#39;audio_tokens\&#39;: 0, \&#39;cached_tokens\&#39;: 0}}, \&#39;model_name\&#39;: \&#39;gpt-4o-mini-2024-07-18\&#39;, \&#39;system_fingerprint\&#39;: \&#39;fp_0705bf87c0\&#39;, \&#39;finish_reason\&#39;: \&#39;stop\&#39;, \&#39;logprobs\&#39;: None}, id=\&#39;run-a2d13a18-7022-4784-b54f-f85c097d1075-0\&#39;, usage_metadata={\&#39;input_tokens\&#39;: 11, \&#39;output_tokens\&#39;: 34, \&#39;total_tokens\&#39;: 45, \&#39;input_token_details\&#39;: {\&#39;audio\&#39;: 0, \&#39;cache_read\&#39;: 0}, \&#39;output_token_details\&#39;: {\&#39;audio\&#39;: 0, \&#39;reasoning\&#39;: 0}})\nLet\&#39;s take a look at the example LangSmith trace\nWe can see that it doesn\&#39;t take the previous conversation turn into context, and cannot answer the question.\nThis makes for a terrible chatbot experience!\nTo get around this, we need to pass the entire conversation history into the model. Let\&#39;s see what happens when we do that:\nfrom langchain_core.messages import AIMessagemodel.invoke(    [        HumanMessage(content=&quot;Hi! I\&#39;m Bob&quot;),        AIMessage(content=&quot;Hello Bob! How can I assist you today?&quot;),        HumanMessage(content=&quot;What\&#39;s my name?&quot;),    ])API Reference:AIMessage\nAIMessage(content=\&#39;Your name is Bob! How can I help you today, Bob?\&#39;, additional_kwargs={\&#39;refusal\&#39;: None}, response_metadata={\&#39;token_usage\&#39;: {\&#39;completion_tokens\&#39;: 14, \&#39;prompt_tokens\&#39;: 33, \&#39;total_tokens\&#39;: 47, \&#39;completion_tokens_details\&#39;: {\&#39;accepted_prediction_tokens\&#39;: 0, \&#39;audio_tokens\&#39;: 0, \&#39;reasoning_tokens\&#39;: 0, \&#39;rejected_prediction_tokens\&#39;: 0}, \&#39;prompt_tokens_details\&#39;: {\&#39;audio_tokens\&#39;: 0, \&#39;cached_tokens\&#39;: 0}}, \&#39;model_name\&#39;: \&#39;gpt-4o-mini-2024-07-18\&#39;, \&#39;system_fingerprint\&#39;: \&#39;fp_0705bf87c0\&#39;, \&#39;finish_reason\&#39;: \&#39;stop\&#39;, \&#39;logprobs\&#39;: None}, id=\&#39;run-34bcccb3-446e-42f2-b1de-52c09936c02c-0\&#39;, usage_metadata={\&#39;input_tokens\&#39;: 33, \&#39;output_tokens\&#39;: 14, \&#39;total_tokens\&#39;: 47, \&#39;input_token_details\&#39;: {\&#39;audio\&#39;: 0, \&#39;cache_read\&#39;: 0}, \&#39;output_token_details\&#39;: {\&#39;audio\&#39;: 0, \&#39;reasoning\&#39;: 0}})\nAnd now we can see that we get a good response!\nThis is the basic idea underpinning a chatbot\&#39;s ability to interact conversationally.\nSo how do we best implement this?\nMessage persistence\u200b\nLangGraph implements a built-in persistence layer, making it ideal for chat applications that support multiple conversational turns.\nWrapping our chat model in a minimal LangGraph application allows us to automatically persist the message history, simplifying the development of multi-turn applications.\nLangGraph comes with a simple in-memory checkpointer, which we use below. See its documentation for more detail, including how to use different persistence backends (e.g., SQLite or Postgres).\nfrom langgraph.checkpoint.memory import MemorySaverfrom langgraph.graph import START, MessagesState, StateGraph# Define a new graphworkflow = StateGraph(state_schema=MessagesState)# Define the function that calls the modeldef call_model(state: MessagesState):    response = model.invoke(state[&quot;messages&quot;])    return {&quot;messages&quot;: response}# Define the (single) node in the graphworkflow.add_edge(START, &quot;model&quot;)workflow.add_node(&quot;model&quot;, call_model)# Add memorymemory = MemorySaver()app = workflow.compile(checkpointer=memory)API Reference:MemorySaver | StateGraph\nWe now need to create a config that we pass into the runnable every time. This config contains information that is not part of the input directly, but is still useful. In this case, we want to include a thread_id. This should look like:\nconfig = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;abc123&quot;}}\nThis enables us to support multiple conversation threads with a single application, a common requirement when your application has multiple users.\nWe can then invoke the application:\nquery = &quot;Hi! I\&#39;m Bob.&quot;input_messages = [HumanMessage(query)]output = app.invoke({&quot;messages&quot;: input_messages}, config)output[&quot;messages&quot;][-1].pretty_print()  # output contains all messages in state\n==================================\x1b[1m Ai Message \x1b[0m==================================Hi Bob! How can I assist you today?\nquery = &quot;What\&#39;s my name?&quot;input_messages = [HumanMessage(query)]output = app.invoke({&quot;messages&quot;: input_messages}, config)output[&quot;messages&quot;][-1].pretty_print()\n==================================\x1b[1m Ai Message \x1b[0m==================================Your name is Bob! How can I help you today, Bob?\nGreat! Our chatbot now remembers things about us. If we change the config to reference a different thread_id, we can see that it starts the conversation fresh.\nconfig = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;abc234&quot;}}input_messages = [HumanMessage(query)]output = app.invoke({&quot;messages&quot;: input_messages}, config)output[&quot;messages&quot;][-1].pretty_print()\n==================================\x1b[1m Ai Message \x1b[0m==================================I\&#39;m sorry, but I don\&#39;t have access to personal information about you unless you\&#39;ve shared it in this conversation. How can I assist you today?\nHowever, we can always go back to the original conversation (since we are persisting it in a database)\nconfig = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;abc123&quot;}}input_messages = [HumanMessage(query)]output = app.invoke({&quot;messages&quot;: input_messages}, config)output[&quot;messages&quot;][-1].pretty_print()\n==================================\x1b[1m Ai Message \x1b[0m==================================Your name is Bob. What would you like to discuss today?\nThis is how we can support a chatbot having conversations with many users!\ntipFor async support, update the call_model node to be an async function and use .ainvoke when invoking the application:# Async function for node:async def call_model(state: MessagesState):    response = await model.ainvoke(state[&quot;messages&quot;])    return {&quot;messages&quot;: response}# Define graph as before:workflow = StateGraph(state_schema=MessagesState)workflow.add_edge(START, &quot;model&quot;)workflow.add_node(&quot;model&quot;, call_model)app = workflow.compile(checkpointer=MemorySaver())# Async invocation:output = await app.ainvoke({&quot;messages&quot;: input_messages}, config)output[&quot;messages&quot;][-1].pretty_print()\nRight now, all we\&#39;ve done is add a simple persistence layer around the model. We can start to make the chatbot more complicated and personalized by adding in a prompt template.\nPrompt templates\u200b\nPrompt Templates help to turn raw user information into a format that the LLM can work with. In this case, the raw user input is just a message, which we are passing to the LLM. Let\&#39;s now make that a bit more complicated. First, let\&#39;s add in a system message with some custom instructions (but still taking messages as input). Next, we\&#39;ll add in more input besides just the messages.\nTo add in a system message, we will create a ChatPromptTemplate. We will utilize MessagesPlaceholder to pass all the messages in.\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholderprompt_template = ChatPromptTemplate.from_messages(    [        (            &quot;system&quot;,            &quot;You talk like a pirate. Answer all questions to the best of your ability.&quot;,        ),        MessagesPlaceholder(variable_name=&quot;messages&quot;),    ])API Reference:ChatPromptTemplate | MessagesPlaceholder\nWe can now update our application to incorporate this template:\nworkflow = StateGraph(state_schema=MessagesState)def call_model(state: MessagesState):    prompt = prompt_template.invoke(state)    response = model.invoke(prompt)    return {&quot;messages&quot;: response}workflow.add_edge(START, &quot;model&quot;)workflow.add_node(&quot;model&quot;, call_model)memory = MemorySaver()app = workflow.compile(checkpointer=memory)\nWe invoke the application in the same way:\nconfig = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;abc345&quot;}}query = &quot;Hi! I\&#39;m Jim.&quot;input_messages = [HumanMessage(query)]output = app.invoke({&quot;messages&quot;: input_messages}, config)output[&quot;messages&quot;][-1].pretty_print()\n==================================\x1b[1m Ai Message \x1b[0m==================================Ahoy there, Jim! What brings ye to these waters today? Be ye seekin\&#39; treasure, knowledge, or perhaps a good tale from the high seas? Arrr!\nquery = &quot;What is my name?&quot;input_messages = [HumanMessage(query)]output = app.invoke({&quot;messages&quot;: input_messages}, config)output[&quot;messages&quot;][-1].pretty_print()\n==================================\x1b[1m Ai Message \x1b[0m==================================Ye be called Jim, matey! A fine name fer a swashbuckler such as yerself! What else can I do fer ye? Arrr!\nAwesome! Let\&#39;s now make our prompt a little bit more complicated. Let\&#39;s assume that the prompt template now looks something like this:\nprompt_template = ChatPromptTemplate.from_messages(    [        (            &quot;system&quot;,            &quot;You are a helpful assistant. Answer all questions to the best of your ability in {language}.&quot;,        ),        MessagesPlaceholder(variable_name=&quot;messages&quot;),    ])\nNote that we have added a new language input to the prompt. Our application now has two parameters-- the input messages and language. We should update our application\&#39;s state to reflect this:\nfrom typing import Sequencefrom langchain_core.messages import BaseMessagefrom langgraph.graph.message import add_messagesfrom typing_extensions import Annotated, TypedDictclass State(TypedDict):    messages: Annotated[Sequence[BaseMessage], add_messages]    language: strworkflow = StateGraph(state_schema=State)def call_model(state: State):    prompt = prompt_template.invoke(state)    response = model.invoke(prompt)    return {&quot;messages&quot;: [response]}workflow.add_edge(START, &quot;model&quot;)workflow.add_node(&quot;model&quot;, call_model)memory = MemorySaver()app = workflow.compile(checkpointer=memory)API Reference:BaseMessage | add_messages\nconfig = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;abc456&quot;}}query = &quot;Hi! I\&#39;m Bob.&quot;language = &quot;Spanish&quot;input_messages = [HumanMessage(query)]output = app.invoke(    {&quot;messages&quot;: input_messages, &quot;language&quot;: language},    config,)output[&quot;messages&quot;][-1].pretty_print()\n==================================\x1b[1m Ai Message \x1b[0m==================================¡Hola, Bob! ¿Cómo puedo ayudarte hoy?\nNote that the entire state is persisted, so we can omit parameters like language if no changes are desired:\nquery = &quot;What is my name?&quot;input_messages = [HumanMessage(query)]output = app.invoke(    {&quot;messages&quot;: input_messages},    config,)output[&quot;messages&quot;][-1].pretty_print()\n==================================\x1b[1m Ai Message \x1b[0m==================================Tu nombre es Bob. ¿Hay algo más en lo que pueda ayudarte?\nTo help you understand what\&#39;s happening internally, check out this LangSmith trace.\nManaging Conversation History\u200b\nOne important concept to understand when building chatbots is how to manage conversation history. If left unmanaged, the list of messages will grow unbounded and potentially overflow the context window of the LLM. Therefore, it is important to add a step that limits the size of the messages you are passing in.\nImportantly, you will want to do this BEFORE the prompt template but AFTER you load previous messages from Message History.\nWe can do this by adding a simple step in front of the prompt that modifies the messages key appropriately, and then wrap that new chain in the Message History class.\nLangChain comes with a few built-in helpers for managing a list of messages. In this case we\&#39;ll use the trim_messages helper to reduce how many messages we\&#39;re sending to the model. The trimmer allows us to specify how many tokens we want to keep, along with other parameters like if we want to always keep the system message and whether to allow partial messages:\nfrom langchain_core.messages import SystemMessage, trim_messagestrimmer = trim_messages(    max_tokens=65,    strategy=&quot;last&quot;,    token_counter=model,    include_system=True,    allow_partial=False,    start_on=&quot;human&quot;,)messages = [    SystemMessage(content=&quot;you\&#39;re a good assistant&quot;),    HumanMessage(content=&quot;hi! I\&#39;m bob&quot;),    AIMessage(content=&quot;hi!&quot;),    HumanMessage(content=&quot;I like vanilla ice cream&quot;),    AIMessage(content=&quot;nice&quot;),    HumanMessage(content=&quot;whats 2 + 2&quot;),    AIMessage(content=&quot;4&quot;),    HumanMessage(content=&quot;thanks&quot;),    AIMessage(content=&quot;no problem!&quot;),    HumanMessage(content=&quot;having fun?&quot;),    AIMessage(content=&quot;yes!&quot;),]trimmer.invoke(messages)API Reference:SystemMessage | trim_messages\n[SystemMessage(content=&quot;you\&#39;re a good assistant&quot;, additional_kwargs={}, response_metadata={}), HumanMessage(content=\&#39;whats 2 + 2\&#39;, additional_kwargs={}, response_metadata={}), AIMessage(content=\&#39;4\&#39;, additional_kwargs={}, response_metadata={}), HumanMessage(content=\&#39;thanks\&#39;, additional_kwargs={}, response_metadata={}), AIMessage(content=\&#39;no problem!\&#39;, additional_kwargs={}, response_metadata={}), HumanMessage(content=\&#39;having fun?\&#39;, additional_kwargs={}, response_metadata={}), AIMessage(content=\&#39;yes!\&#39;, additional_kwargs={}, response_metadata={})]\nTo  use it in our chain, we just need to run the trimmer before we pass the messages input to our prompt.\nworkflow = StateGraph(state_schema=State)def call_model(state: State):    print(f&quot;Messages before trimming: {len(state[\&#39;messages\&#39;])}&quot;)    trimmed_messages = trimmer.invoke(state[&quot;messages&quot;])    print(f&quot;Messages after trimming: {len(trimmed_messages)}&quot;)    print(&quot;Remaining messages:&quot;)    for msg in trimmed_messages:        print(f&quot;  {type(msg).__name__}: {msg.content}&quot;)    prompt = prompt_template.invoke(        {&quot;messages&quot;: trimmed_messages, &quot;language&quot;: state[&quot;language&quot;]}    )    response = model.invoke(prompt)    return {&quot;messages&quot;: [response]}workflow.add_edge(START, &quot;model&quot;)workflow.add_node(&quot;model&quot;, call_model)memory = MemorySaver()app = workflow.compile(checkpointer=memory)\nNow if we try asking the model our name, it won\&#39;t know it since we trimmed that part of the chat history. (By defining our trim stragegy as \&#39;last\&#39;, we are only keeping the most recent messages that fit within the max_tokens.)\nconfig = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;abc567&quot;}}query = &quot;What is my name?&quot;language = &quot;English&quot;input_messages = messages + [HumanMessage(query)]output = app.invoke(    {&quot;messages&quot;: input_messages, &quot;language&quot;: language},    config,)output[&quot;messages&quot;][-1].pretty_print()\nMessages before trimming: 12Messages after trimming: 8Remaining messages:  SystemMessage: you\&#39;re a good assistant  HumanMessage: whats 2 + 2  AIMessage: 4  HumanMessage: thanks  AIMessage: no problem!  HumanMessage: having fun?  AIMessage: yes!  HumanMessage: What is my name?==================================\x1b[1m Ai Message \x1b[0m==================================I don\&#39;t know your name. If you\&#39;d like to share it, feel free!\nBut if we ask about information that is within the last few messages, it remembers:\nconfig = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;abc678&quot;}}query = &quot;What math problem was asked?&quot;language = &quot;English&quot;input_messages = messages + [HumanMessage(query)]output = app.invoke(    {&quot;messages&quot;: input_messages, &quot;language&quot;: language},    config,)output[&quot;messages&quot;][-1].pretty_print()\nMessages before trimming: 12Messages after trimming: 8Remaining messages:  SystemMessage: you\&#39;re a good assistant  HumanMessage: whats 2 + 2  AIMessage: 4  HumanMessage: thanks  AIMessage: no problem!  HumanMessage: having fun?  AIMessage: yes!  HumanMessage: What math problem was asked?==================================\x1b[1m Ai Message \x1b[0m==================================The math problem that was asked was &quot;what\&#39;s 2 + 2.&quot;\nIf you take a look at LangSmith, you can see exactly what is happening under the hood in the LangSmith trace.\nStreaming\u200b\nNow we\&#39;ve got a functioning chatbot. However, one really important UX consideration for chatbot applications is streaming. LLMs can sometimes take a while to respond, and so in order to improve the user experience one thing that most applications do is stream back each token as it is generated. This allows the user to see progress.\nIt\&#39;s actually super easy to do this!\nBy default, .stream in our LangGraph application streams application steps-- in this case, the single step of the model response. Setting stream_mode=&quot;messages&quot; allows us to stream output tokens instead:\nconfig = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;abc789&quot;}}query = &quot;Hi I\&#39;m Todd, please tell me a joke.&quot;language = &quot;English&quot;input_messages = [HumanMessage(query)]for chunk, metadata in app.stream(    {&quot;messages&quot;: input_messages, &quot;language&quot;: language},    config,    stream_mode=&quot;messages&quot;,):    if isinstance(chunk, AIMessage):  # Filter to just model responses        print(chunk.content, end=&quot;|&quot;)\n|Hi| Todd|!| Here|’s| a| joke| for| you|:|Why| don\&#39;t| scientists| trust| atoms|?|Because| they| make| up| everything|!||\nNext Steps\u200b\nNow that you understand the basics of how to create a chatbot in LangChain, some more advanced tutorials you may be interested in are:\n\nConversational RAG: Enable a chatbot experience over an external source of data\nAgents: Build a chatbot that can take actions\n\nIf you want to dive deeper on specifics, some things worth checking out are:\n\nStreaming: streaming is crucial for chat applications\nHow to add message history: for a deeper dive into all things related to message history\nHow to manage large message history: more techniques for managing a large chat history\nLangGraph main docs: for more detail on building with LangGraph\nEdit this pagePreviousBuild a simple LLM application with chat models and prompt templatesNextBuild a Retrieval Augmented Generation (RAG) App: Part 2OverviewSetupJupyter NotebookInstallationLangSmithQuickstartMessage persistencePrompt templatesManaging Conversation HistoryStreamingNext StepsCommunityLangChain ForumTwitterSlackGitHubOrganizationPythonJS/TSMoreHomepageBlogYouTubeCopyright © 2025 LangChain, Inc.\n\n&#39;)],
 [Document(metadata={&#39;source&#39;: &#39;https://python.langchain.com/docs/tutorials/qa_chat_history/&#39;, &#39;title&#39;: &#39;Build a Retrieval Augmented Generation (RAG) App: Part 2 | 🦜️🔗 LangChain&#39;, &#39;description&#39;: &#39;In many Q&amp;A applications we want to allow the user to have a back-and-forth conversation, meaning the application needs some sort of &quot;memory&quot; of past questions and answers, and some logic for incorporating those into its current thinking.&#39;, &#39;language&#39;: &#39;en&#39;}, page_content=&#39;\n\n\n\n\nBuild a Retrieval Augmented Generation (RAG) App: Part 2 | 🦜️🔗 LangChain\n\n\n\n\n\n\n\n\nSkip to main content⚠️ THESE DOCS ARE OUTDATED. Visit the new v1.0 docsIntegrationsAPI ReferenceMoreContributingPeopleError referenceLangSmithLangGraphLangChain HubLangChain JS/TSv0.3v0.3v0.2v0.1💬SearchIntroductionTutorialsBuild a Question Answering application over a Graph DatabaseindexBuild a simple LLM application with chat models and prompt templatesBuild a ChatbotBuild a Retrieval Augmented Generation (RAG) App: Part 2Build an Extraction ChainBuild an AgentTaggingBuild a Retrieval Augmented Generation (RAG) App: Part 1Build a semantic search engineBuild a Question/Answering system over SQL dataSummarize TextHow-to guidesindexHow to use tools in a chainHow to use a vectorstore as a retrieverHow to add memory to chatbotsHow to use example selectorsHow to add a semantic layer over graph databaseHow to invoke runnables in parallelHow to stream chat model responsesHow to add default invocation args to a RunnableHow to add retrieval to chatbotsHow to use few shot examples in chat modelsHow to do tool/function callingHow to install LangChain packagesHow to add examples to the prompt for query analysisHow to use few shot examplesHow to run custom functionsHow to use output parsers to parse an LLM response into structured formatHow to handle cases where no queries are generatedHow to route between sub-chainsHow to return structured data from a modelHow to summarize text through parallelizationHow to summarize text through iterative refinementHow to summarize text in a single LLM callHow to use toolkitsHow to add ad-hoc tool calling capability to LLMs and Chat ModelsBuild an Agent with AgentExecutor (Legacy)How to construct knowledge graphsHow to partially format prompt templatesHow to handle multiple queries when doing query analysisHow to use built-in tools and toolkitsHow to pass through arguments from one step to the nextHow to compose prompts togetherHow to handle multiple retrievers when doing query analysisHow to add values to a chain\&#39;s stateHow to construct filters for query analysisHow to configure runtime chain internalsHow to deal with high-cardinality categoricals when doing query analysisCustom Document LoaderHow to use the MultiQueryRetrieverHow to add scores to retriever resultsCachingHow to use callbacks in async environmentsHow to attach callbacks to a runnableHow to propagate callbacks  constructorHow to dispatch custom callback eventsHow to pass callbacks in at runtimeHow to split by characterHow to cache chat model responsesHow to handle rate limitsHow to init any model in one lineHow to track token usage in ChatModelsHow to add tools to chatbotsHow to split codeHow to do retrieval with contextual compressionHow to convert Runnables to ToolsHow to create custom callback handlersHow to create a custom chat model classCustom EmbeddingsHow to create a custom LLM classCustom RetrieverHow to create toolsHow to debug your LLM appsHow to load CSVsHow to load documents from a directoryHow to load HTMLHow to load JSONHow to load MarkdownHow to load Microsoft Office filesHow to load PDFsHow to load web pagesHow to create a dynamic (self-constructing) chainText embedding modelsHow to combine results from multiple retrieversHow to select examples from a LangSmith datasetHow to select examples by lengthHow to select examples by maximal marginal relevance (MMR)How to select examples by n-gram overlapHow to select examples by similarityHow to use reference examples when doing extractionHow to handle long text when doing extractionHow to use prompting alone (no tool calling) to do extractionHow to add fallbacks to a runnableHow to filter messagesHybrid SearchHow to use the LangChain indexing APIHow to inspect runnablesLangChain Expression Language CheatsheetHow to cache LLM responsesHow to track token usage for LLMsRun models locallyHow to get log probabilitiesHow to reorder retrieved results to mitigate the &quot;lost in the middle&quot; effectHow to split Markdown by HeadersHow to merge consecutive messages of the same typeHow to add message historyHow to migrate from legacy LangChain agents to LangGraphHow to retrieve using multiple vectors per documentHow to pass multimodal data to modelsHow to use multimodal promptsHow to create a custom Output ParserHow to use the output-fixing parserHow to parse JSON outputHow to retry when a parsing error occursHow to parse text from message objectsHow to parse XML outputHow to parse YAML outputHow to use the Parent Document RetrieverHow to use LangChain with different Pydantic versionsHow to add chat historyHow to get a RAG application to add citationsHow to do per-user retrievalHow to get your RAG application to return sourcesHow to stream results from your RAG applicationHow to split JSON dataHow to recursively split text by charactersResponse metadataHow to pass runtime secrets to runnablesHow to do &quot;self-querying&quot; retrievalHow to split text based on semantic similarityHow to chain runnablesHow to save and load LangChain objectsHow to split text by tokensHow to split HTMLHow to do question answering over CSVsHow to deal with large databases when doing SQL question-answeringHow to better prompt when doing SQL question-answeringHow to do query validation as part of SQL question-answeringHow to stream runnablesHow to stream responses from an LLMHow to use a time-weighted vector store retrieverHow to return artifacts from a toolHow to use chat models to call toolsHow to disable parallel tool callingHow to force models to call a toolHow to access the RunnableConfig from a toolHow to pass tool outputs to chat modelsHow to pass run time values to toolsHow to stream events from a toolHow to stream tool callsHow to convert tools to OpenAI FunctionsHow to handle tool errorsHow to use few-shot prompting with tool callingHow to add a human-in-the-loop for toolsHow to bind model-specific toolsHow to trim messagesHow to create and query vector storesConceptual guideAgentsArchitectureAsync programming with LangChainCallbacksChat historyChat modelsDocument loadersEmbedding modelsEvaluationExample selectorsFew-shot promptingindexKey-value storesLangChain Expression Language (LCEL)MessagesMultimodalityOutput parsersPrompt TemplatesRetrieval augmented generation (RAG)RetrievalRetrieversRunnable interfaceStreamingStructured outputsTestingString-in, string-out llmsText splittersTokensTool callingToolsTracingVector storesWhy LangChain?Ecosystem🦜🛠️ LangSmith🦜🕸️ LangGraphVersionsv0.3v0.2Pydantic compatibilityMigrating from v0.0 chainsHow to migrate from v0.0 chainsMigrating from ConstitutionalChainMigrating from ConversationalChainMigrating from ConversationalRetrievalChainMigrating from LLMChainMigrating from LLMMathChainMigrating from LLMRouterChainMigrating from MapReduceDocumentsChainMigrating from MapRerankDocumentsChainMigrating from MultiPromptChainMigrating from RefineDocumentsChainMigrating from RetrievalQAMigrating from StuffDocumentsChainUpgrading to LangGraph memoryHow to migrate to LangGraph memoryHow to use BaseChatMessageHistory with LangGraphMigrating off ConversationBufferMemory or ConversationStringBufferMemoryMigrating off ConversationBufferWindowMemory or ConversationTokenBufferMemoryMigrating off ConversationSummaryMemory or ConversationSummaryBufferMemoryA Long-Term Memory AgentRelease policySecurity PolicyTutorialsBuild a Retrieval Augmented Generation (RAG) App: Part 2On this pageBuild a Retrieval Augmented Generation (RAG) App: Part 2\nIn many Q&amp;A applications we want to allow the user to have a back-and-forth conversation, meaning the application needs some sort of &quot;memory&quot; of past questions and answers, and some logic for incorporating those into its current thinking.\nThis is the second part of a multi-part tutorial:\n\nPart 1 introduces RAG and walks through a minimal implementation.\nPart 2 (this guide) extends the implementation to accommodate conversation-style interactions and multi-step retrieval processes.\n\nHere we focus on adding logic for incorporating historical messages. This involves the management of a chat history.\nWe will cover two approaches:\n\nChains, in which we execute at most one retrieval step;\nAgents, in which we give an LLM discretion to execute multiple retrieval steps.\n\nnoteThe methods presented here leverage tool-calling capabilities in modern chat models. See this page for a table of models supporting tool calling features.\nFor the external knowledge source, we will use the same LLM Powered Autonomous Agents blog post by Lilian Weng from the Part 1 of the RAG tutorial.\nSetup\u200b\nComponents\u200b\nWe will need to select three components from LangChain\&#39;s suite of integrations.\n\nSelect chat model:Google Gemini▾OpenAIAnthropicAzureGoogle GeminiGoogle VertexAWSGroqCohereNVIDIAFireworks AIMistral AITogether AIIBM watsonxDatabricksxAIPerplexityDeepSeekChatOCIGenAIpip install -qU &quot;langchain[google-genai]&quot;import getpassimport osif not os.environ.get(&quot;GOOGLE_API_KEY&quot;):  os.environ[&quot;GOOGLE_API_KEY&quot;] = getpass.getpass(&quot;Enter API key for Google Gemini: &quot;)from langchain.chat_models import init_chat_modelllm = init_chat_model(&quot;gemini-2.5-flash&quot;, model_provider=&quot;google_genai&quot;)\n\nSelect embeddings model:OpenAI▾OpenAIAzureGoogle GeminiGoogle VertexAWSHuggingFaceOllamaCohereMistralAINomicNVIDIAVoyage AIIBM watsonxFakeOCIGenAIEmbeddingspip install -qU langchain-openaiimport getpassimport osif not os.environ.get(&quot;OPENAI_API_KEY&quot;):  os.environ[&quot;OPENAI_API_KEY&quot;] = getpass.getpass(&quot;Enter API key for OpenAI: &quot;)from langchain_openai import OpenAIEmbeddingsembeddings = OpenAIEmbeddings(model=&quot;text-embedding-3-large&quot;)\n\nSelect vector store:In-memory▾In-memoryAstraDBChromaFAISSMilvusMongoDBPGVectorPGVectorStorePineconeQdrantpip install -qU langchain-corefrom langchain_core.vectorstores import InMemoryVectorStorevector_store = InMemoryVectorStore(embeddings)\nDependencies\u200b\nIn addition, we\&#39;ll use the following packages:\n%%capture --no-stderr%pip install --upgrade --quiet langgraph langchain-community beautifulsoup4\nLangSmith\u200b\nMany of the applications you build with LangChain will contain multiple steps with multiple invocations of LLM calls. As these applications get more and more complex, it becomes crucial to be able to inspect what exactly is going on inside your chain or agent. The best way to do this is with LangSmith.\nNote that LangSmith is not needed, but it is helpful. If you do want to use LangSmith, after you sign up at the link above, make sure to set your environment variables to start logging traces:\nos.environ[&quot;LANGSMITH_TRACING&quot;] = &quot;true&quot;if not os.environ.get(&quot;LANGSMITH_API_KEY&quot;):    os.environ[&quot;LANGSMITH_API_KEY&quot;] = getpass.getpass()\nChains\u200b\nLet\&#39;s first revisit the vector store we built in Part 1, which indexes an LLM Powered Autonomous Agents blog post by Lilian Weng.\nimport bs4from langchain import hubfrom langchain_community.document_loaders import WebBaseLoaderfrom langchain_core.documents import Documentfrom langchain_text_splitters import RecursiveCharacterTextSplitterfrom typing_extensions import List, TypedDict# Load and chunk contents of the blogloader = WebBaseLoader(    web_paths=(&quot;https://lilianweng.github.io/posts/2023-06-23-agent/&quot;,),    bs_kwargs=dict(        parse_only=bs4.SoupStrainer(            class_=(&quot;post-content&quot;, &quot;post-title&quot;, &quot;post-header&quot;)        )    ),)docs = loader.load()text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)all_splits = text_splitter.split_documents(docs)API Reference:Document\n# Index chunks_ = vector_store.add_documents(documents=all_splits)\nIn the Part 1 of the RAG tutorial, we represented the user input, retrieved context, and generated answer as separate keys in the state. Conversational experiences can be naturally represented using a sequence of messages. In addition to messages from the user and assistant, retrieved documents and other artifacts can be incorporated into a message sequence via tool messages. This motivates us to represent the state of our RAG application using a sequence of messages. Specifically, we will have\n\nUser input as a HumanMessage;\nVector store query as an AIMessage with tool calls;\nRetrieved documents as a ToolMessage;\nFinal response as a AIMessage.\n\nThis model for state is so versatile that LangGraph offers a built-in version for convenience:\nfrom langgraph.graph import MessagesState, StateGraphgraph_builder = StateGraph(MessagesState)API Reference:StateGraph\nLeveraging tool-calling to interact with a retrieval step has another benefit, which is that the query for the retrieval is generated by our model. This is especially important in a conversational setting, where user queries may require contextualization based on the chat history. For instance, consider the following exchange:\n\nHuman: &quot;What is Task Decomposition?&quot;\nAI: &quot;Task decomposition involves breaking down complex tasks into smaller and simpler steps to make them more manageable for an agent or model.&quot;\nHuman: &quot;What are common ways of doing it?&quot;\n\nIn this scenario, a model could generate a query such as &quot;common approaches to task decomposition&quot;. Tool-calling facilitates this naturally. As in the query analysis section of the RAG tutorial, this allows a model to rewrite user queries into more effective search queries. It also provides support for direct responses that do not involve a retrieval step (e.g., in response to a generic greeting from the user).\nLet\&#39;s turn our retrieval step into a tool:\nfrom langchain_core.tools import tool@tool(response_format=&quot;content_and_artifact&quot;)def retrieve(query: str):    &quot;&quot;&quot;Retrieve information related to a query.&quot;&quot;&quot;    retrieved_docs = vector_store.similarity_search(query, k=2)    serialized = &quot;\\n\\n&quot;.join(        (f&quot;Source: {doc.metadata}\\nContent: {doc.page_content}&quot;)        for doc in retrieved_docs    )    return serialized, retrieved_docsAPI Reference:tool\nSee this guide for more detail on creating tools.\nOur graph will consist of three nodes:\n\nA node that fields the user input, either generating a query for the retriever or responding directly;\nA node for the retriever tool that executes the retrieval step;\nA node that generates the final response using the retrieved context.\n\nWe build them below. Note that we leverage another pre-built LangGraph component, ToolNode, that executes the tool and adds the result as a ToolMessage to the state.\nfrom langchain_core.messages import SystemMessagefrom langgraph.prebuilt import ToolNode# Step 1: Generate an AIMessage that may include a tool-call to be sent.def query_or_respond(state: MessagesState):    &quot;&quot;&quot;Generate tool call for retrieval or respond.&quot;&quot;&quot;    llm_with_tools = llm.bind_tools([retrieve])    response = llm_with_tools.invoke(state[&quot;messages&quot;])    # MessagesState appends messages to state instead of overwriting    return {&quot;messages&quot;: [response]}# Step 2: Execute the retrieval.tools = ToolNode([retrieve])# Step 3: Generate a response using the retrieved content.def generate(state: MessagesState):    &quot;&quot;&quot;Generate answer.&quot;&quot;&quot;    # Get generated ToolMessages    recent_tool_messages = []    for message in reversed(state[&quot;messages&quot;]):        if message.type == &quot;tool&quot;:            recent_tool_messages.append(message)        else:            break    tool_messages = recent_tool_messages[::-1]    # Format into prompt    docs_content = &quot;\\n\\n&quot;.join(doc.content for doc in tool_messages)    system_message_content = (        &quot;You are an assistant for question-answering tasks. &quot;        &quot;Use the following pieces of retrieved context to answer &quot;        &quot;the question. If you don\&#39;t know the answer, say that you &quot;        &quot;don\&#39;t know. Use three sentences maximum and keep the &quot;        &quot;answer concise.&quot;        &quot;\\n\\n&quot;        f&quot;{docs_content}&quot;    )    conversation_messages = [        message        for message in state[&quot;messages&quot;]        if message.type in (&quot;human&quot;, &quot;system&quot;)        or (message.type == &quot;ai&quot; and not message.tool_calls)    ]    prompt = [SystemMessage(system_message_content)] + conversation_messages    # Run    response = llm.invoke(prompt)    return {&quot;messages&quot;: [response]}API Reference:SystemMessage | ToolNode\nFinally, we compile our application into a single graph object. In this case, we are just connecting the steps into a sequence. We also allow the first query_or_respond step to &quot;short-circuit&quot; and respond directly to the user if it does not generate a tool call. This allows our application to support conversational experiences-- e.g., responding to generic greetings that may not require a retrieval step\nfrom langgraph.graph import ENDfrom langgraph.prebuilt import ToolNode, tools_conditiongraph_builder.add_node(query_or_respond)graph_builder.add_node(tools)graph_builder.add_node(generate)graph_builder.set_entry_point(&quot;query_or_respond&quot;)graph_builder.add_conditional_edges(    &quot;query_or_respond&quot;,    tools_condition,    {END: END, &quot;tools&quot;: &quot;tools&quot;},)graph_builder.add_edge(&quot;tools&quot;, &quot;generate&quot;)graph_builder.add_edge(&quot;generate&quot;, END)graph = graph_builder.compile()API Reference:ToolNode | tools_condition\nfrom IPython.display import Image, displaydisplay(Image(graph.get_graph().draw_mermaid_png()))\n\nLet\&#39;s test our application.\nNote that it responds appropriately to messages that do not require an additional retrieval step:\ninput_message = &quot;Hello&quot;for step in graph.stream(    {&quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: input_message}]},    stream_mode=&quot;values&quot;,):    step[&quot;messages&quot;][-1].pretty_print()\n================================\x1b[1m Human Message \x1b[0m=================================Hello==================================\x1b[1m Ai Message \x1b[0m==================================Hello! How can I assist you today?\nAnd when executing a search, we can stream the steps to observe the query generation, retrieval, and answer generation:\ninput_message = &quot;What is Task Decomposition?&quot;for step in graph.stream(    {&quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: input_message}]},    stream_mode=&quot;values&quot;,):    step[&quot;messages&quot;][-1].pretty_print()\n================================\x1b[1m Human Message \x1b[0m=================================What is Task Decomposition?==================================\x1b[1m Ai Message \x1b[0m==================================Tool Calls:  retrieve (call_dLjB3rkMoxZZxwUGXi33UBeh) Call ID: call_dLjB3rkMoxZZxwUGXi33UBeh  Args:    query: Task Decomposition=================================\x1b[1m Tool Message \x1b[0m=================================Name: retrieveSource: {\&#39;source\&#39;: \&#39;https://lilianweng.github.io/posts/2023-06-23-agent/\&#39;}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.Source: {\&#39;source\&#39;: \&#39;https://lilianweng.github.io/posts/2023-06-23-agent/\&#39;}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like &quot;Steps for XYZ.\\n1.&quot;, &quot;What are the subgoals for achieving XYZ?&quot;, (2) by using task-specific instructions; e.g. &quot;Write a story outline.&quot; for writing a novel, or (3) with human inputs.==================================\x1b[1m Ai Message \x1b[0m==================================Task Decomposition is the process of breaking down a complicated task into smaller, manageable steps. It often involves techniques like Chain of Thought (CoT), which encourages models to think step by step, enhancing performance on complex tasks. This approach allows for a clearer understanding of the task and aids in structuring the problem-solving process.\nCheck out the LangSmith trace here.\nStateful management of chat history\u200b\nnoteThis section of the tutorial previously used the RunnableWithMessageHistory abstraction. You can access that version of the documentation in the v0.2 docs.As of the v0.3 release of LangChain, we recommend that LangChain users take advantage of LangGraph persistence to incorporate memory into new LangChain applications.If your code is already relying on RunnableWithMessageHistory or BaseChatMessageHistory, you do not need to make any changes. We do not plan on deprecating this functionality in the near future as it works for simple chat applications and any code that uses RunnableWithMessageHistory will continue to work as expected.Please see How to migrate to LangGraph Memory for more details.\nIn production, the Q&amp;A application will usually persist the chat history into a database, and be able to read and update it appropriately.\nLangGraph implements a built-in persistence layer, making it ideal for chat applications that support multiple conversational turns.\nTo manage multiple conversational turns and threads, all we have to do is specify a checkpointer when compiling our application. Because the nodes in our graph are appending messages to the state, we will retain a consistent chat history across invocations.\nLangGraph comes with a simple in-memory checkpointer, which we use below. See its documentation for more detail, including how to use different persistence backends (e.g., SQLite or Postgres).\nFor a detailed walkthrough of how to manage message history, head to the How to add message history (memory) guide.\nfrom langgraph.checkpoint.memory import MemorySavermemory = MemorySaver()graph = graph_builder.compile(checkpointer=memory)# Specify an ID for the threadconfig = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;abc123&quot;}}API Reference:MemorySaver\nWe can now invoke similar to before:\ninput_message = &quot;What is Task Decomposition?&quot;for step in graph.stream(    {&quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: input_message}]},    stream_mode=&quot;values&quot;,    config=config,):    step[&quot;messages&quot;][-1].pretty_print()\n================================\x1b[1m Human Message \x1b[0m=================================What is Task Decomposition?==================================\x1b[1m Ai Message \x1b[0m==================================Tool Calls:  retrieve (call_JZb6GLD812bW2mQsJ5EJQDnN) Call ID: call_JZb6GLD812bW2mQsJ5EJQDnN  Args:    query: Task Decomposition=================================\x1b[1m Tool Message \x1b[0m=================================Name: retrieveSource: {\&#39;source\&#39;: \&#39;https://lilianweng.github.io/posts/2023-06-23-agent/\&#39;}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.Source: {\&#39;source\&#39;: \&#39;https://lilianweng.github.io/posts/2023-06-23-agent/\&#39;}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like &quot;Steps for XYZ.\\n1.&quot;, &quot;What are the subgoals for achieving XYZ?&quot;, (2) by using task-specific instructions; e.g. &quot;Write a story outline.&quot; for writing a novel, or (3) with human inputs.==================================\x1b[1m Ai Message \x1b[0m==================================Task Decomposition is a technique used to break down complicated tasks into smaller, manageable steps. It involves using methods like Chain of Thought (CoT) prompting, which encourages the model to think step by step, enhancing performance on complex tasks. This process helps to clarify the model\&#39;s reasoning and makes it easier to tackle difficult problems.\ninput_message = &quot;Can you look up some common ways of doing it?&quot;for step in graph.stream(    {&quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: input_message}]},    stream_mode=&quot;values&quot;,    config=config,):    step[&quot;messages&quot;][-1].pretty_print()\n================================\x1b[1m Human Message \x1b[0m=================================Can you look up some common ways of doing it?==================================\x1b[1m Ai Message \x1b[0m==================================Tool Calls:  retrieve (call_kjRI4Y5cJOiB73yvd7dmb6ux) Call ID: call_kjRI4Y5cJOiB73yvd7dmb6ux  Args:    query: common methods of task decomposition=================================\x1b[1m Tool Message \x1b[0m=================================Name: retrieveSource: {\&#39;source\&#39;: \&#39;https://lilianweng.github.io/posts/2023-06-23-agent/\&#39;}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like &quot;Steps for XYZ.\\n1.&quot;, &quot;What are the subgoals for achieving XYZ?&quot;, (2) by using task-specific instructions; e.g. &quot;Write a story outline.&quot; for writing a novel, or (3) with human inputs.Source: {\&#39;source\&#39;: \&#39;https://lilianweng.github.io/posts/2023-06-23-agent/\&#39;}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.==================================\x1b[1m Ai Message \x1b[0m==================================Common ways of performing Task Decomposition include: (1) using Large Language Models (LLMs) with simple prompts like &quot;Steps for XYZ&quot; or &quot;What are the subgoals for achieving XYZ?&quot;, (2) employing task-specific instructions such as &quot;Write a story outline&quot; for specific tasks, and (3) incorporating human inputs to guide the decomposition process.\nNote that the query generated by the model in the second question incorporates the conversational context.\nThe LangSmith trace is particularly informative here, as we can see exactly what messages are visible to our chat model at each step.\nAgents\u200b\nAgents leverage the reasoning capabilities of LLMs to make decisions during execution. Using agents allows you to offload additional discretion over the retrieval process. Although their behavior is less predictable than the above &quot;chain&quot;, they are able to execute multiple retrieval steps in service of a query, or iterate on a single search.\nBelow we assemble a minimal RAG agent. Using LangGraph\&#39;s pre-built ReAct agent constructor, we can do this in one line.\ntipCheck out LangGraph\&#39;s Agentic RAG tutorial for more advanced formulations.\nfrom langgraph.prebuilt import create_react_agentagent_executor = create_react_agent(llm, [retrieve], checkpointer=memory)API Reference:create_react_agent\nLet\&#39;s inspect the graph:\ndisplay(Image(agent_executor.get_graph().draw_mermaid_png()))\n\nThe key difference from our earlier implementation is that instead of a final generation step that ends the run, here the tool invocation loops back to the original LLM call. The model can then either answer the question using the retrieved context, or generate another tool call to obtain more information.\nLet\&#39;s test this out. We construct a question that would typically require an iterative sequence of retrieval steps to answer:\nconfig = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;def234&quot;}}input_message = (    &quot;What is the standard method for Task Decomposition?\\n\\n&quot;    &quot;Once you get the answer, look up common extensions of that method.&quot;)for event in agent_executor.stream(    {&quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: input_message}]},    stream_mode=&quot;values&quot;,    config=config,):    event[&quot;messages&quot;][-1].pretty_print()\n================================\x1b[1m Human Message \x1b[0m=================================What is the standard method for Task Decomposition?Once you get the answer, look up common extensions of that method.==================================\x1b[1m Ai Message \x1b[0m==================================Tool Calls:  retrieve (call_Y3YaIzL71B83Cjqa8d2G0O8N) Call ID: call_Y3YaIzL71B83Cjqa8d2G0O8N  Args:    query: standard method for Task Decomposition=================================\x1b[1m Tool Message \x1b[0m=================================Name: retrieveSource: {\&#39;source\&#39;: \&#39;https://lilianweng.github.io/posts/2023-06-23-agent/\&#39;}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like &quot;Steps for XYZ.\\n1.&quot;, &quot;What are the subgoals for achieving XYZ?&quot;, (2) by using task-specific instructions; e.g. &quot;Write a story outline.&quot; for writing a novel, or (3) with human inputs.Source: {\&#39;source\&#39;: \&#39;https://lilianweng.github.io/posts/2023-06-23-agent/\&#39;}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.==================================\x1b[1m Ai Message \x1b[0m==================================Tool Calls:  retrieve (call_2JntP1x4XQMWwgVpYurE12ff) Call ID: call_2JntP1x4XQMWwgVpYurE12ff  Args:    query: common extensions of Task Decomposition methods=================================\x1b[1m Tool Message \x1b[0m=================================Name: retrieveSource: {\&#39;source\&#39;: \&#39;https://lilianweng.github.io/posts/2023-06-23-agent/\&#39;}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like &quot;Steps for XYZ.\\n1.&quot;, &quot;What are the subgoals for achieving XYZ?&quot;, (2) by using task-specific instructions; e.g. &quot;Write a story outline.&quot; for writing a novel, or (3) with human inputs.Source: {\&#39;source\&#39;: \&#39;https://lilianweng.github.io/posts/2023-06-23-agent/\&#39;}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.==================================\x1b[1m Ai Message \x1b[0m==================================The standard method for task decomposition involves using techniques such as Chain of Thought (CoT), where a model is instructed to &quot;think step by step&quot; to break down complex tasks into smaller, more manageable components. This approach enhances model performance by allowing for more thorough reasoning and planning. Task decomposition can be accomplished through various means, including:1. Simple prompting (e.g., asking for steps to achieve a goal).2. Task-specific instructions (e.g., asking for a story outline).3. Human inputs to guide the decomposition process.### Common Extensions of Task Decomposition Methods:1. **Tree of Thoughts**: This extension builds on CoT by not only decomposing the problem into thought steps but also generating multiple thoughts at each step, creating a tree structure. The search process can employ breadth-first search (BFS) or depth-first search (DFS), with each state evaluated by a classifier or through majority voting.These extensions aim to enhance reasoning capabilities and improve the effectiveness of task decomposition in various contexts.\nNote that the agent:\n\nGenerates a query to search for a standard method for task decomposition;\nReceiving the answer, generates a second query to search for common extensions of it;\nHaving received all necessary context, answers the question.\n\nWe can see the full sequence of steps, along with latency and other metadata, in the LangSmith trace.\nNext steps\u200b\nWe\&#39;ve covered the steps to build a basic conversational Q&amp;A application:\n\nWe used chains to build a predictable application that generates at most one query per user input;\nWe used agents to build an application that can iterate on a sequence of queries.\n\nTo explore different types of retrievers and retrieval strategies, visit the retrievers section of the how-to guides.\nFor a detailed walkthrough of LangChain\&#39;s conversation memory abstractions, visit the How to add message history (memory) guide.\nTo learn more about agents, check out the conceptual guide and LangGraph agent architectures page.Edit this pagePreviousBuild a ChatbotNextBuild an Extraction ChainSetupComponentsDependenciesLangSmithChainsStateful management of chat historyAgentsNext stepsCommunityLangChain ForumTwitterSlackGitHubOrganizationPythonJS/TSMoreHomepageBlogYouTubeCopyright © 2025 LangChain, Inc.\n\n&#39;)]]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">docs_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">docs</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

<span class="n">text_splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="p">(</span>
    <span class="n">chunk_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">100</span>
<span class="p">)</span>

<span class="n">doc_splits</span> <span class="o">=</span> <span class="n">text_splitter</span><span class="o">.</span><span class="n">split_documents</span><span class="p">(</span><span class="n">docs_list</span><span class="p">)</span>

<span class="c1">## Add alll these text to vectordb</span>

<span class="n">vectorstorelangchain</span><span class="o">=</span><span class="n">FAISS</span><span class="o">.</span><span class="n">from_documents</span><span class="p">(</span>
    <span class="n">documents</span><span class="o">=</span><span class="n">doc_splits</span><span class="p">,</span>
    <span class="n">embedding</span><span class="o">=</span><span class="n">OpenAIEmbeddings</span><span class="p">()</span>
<span class="p">)</span>


<span class="n">retrieverlangchain</span><span class="o">=</span><span class="n">vectorstorelangchain</span><span class="o">.</span><span class="n">as_retriever</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">langchain_core.tools.retriever</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_retriever_tool</span>

<span class="n">retriever_tool_langchain</span><span class="o">=</span><span class="n">create_retriever_tool</span><span class="p">(</span>
    <span class="n">retrieverlangchain</span><span class="p">,</span>
    <span class="s2">&quot;retriever_vector_langchain_blog&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Search and run information about Langchain&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="n">retriever_tool</span><span class="p">,</span><span class="n">retriever_tool_langchain</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="langgraph-workflow">
<h1>LangGraph Workflow<a class="headerlink" href="#langgraph-workflow" title="Link to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypedDict</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">langchain_core.messages</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseMessage</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">langgraph.graph.message</span><span class="w"> </span><span class="kn">import</span> <span class="n">add_messages</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AgentState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="c1"># The add_messages function defines how an update should be processed</span>
    <span class="c1"># Default is to replace. add_messages says &quot;append&quot;</span>
    <span class="n">messages</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">BaseMessage</span><span class="p">],</span> <span class="n">add_messages</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">langchain_groq</span><span class="w"> </span><span class="kn">import</span> <span class="n">ChatGroq</span>

<span class="n">llm</span><span class="o">=</span><span class="n">ChatGroq</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;openai/gpt-oss-120b&quot;</span><span class="p">)</span>
<span class="n">llm</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="s2">&quot;Hi&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AIMessage(content=&#39;Hello! How can I help you today?&#39;, additional_kwargs={&#39;reasoning_content&#39;: &#39;The user says &quot;Hi&quot;. We need to respond appropriately. It\&#39;s a simple greeting. We can respond friendly.&#39;}, response_metadata={&#39;token_usage&#39;: {&#39;completion_tokens&#39;: 41, &#39;prompt_tokens&#39;: 72, &#39;total_tokens&#39;: 113, &#39;completion_time&#39;: 0.086227635, &#39;prompt_time&#39;: 0.00269933, &#39;queue_time&#39;: 0.04773908, &#39;total_time&#39;: 0.088926965}, &#39;model_name&#39;: &#39;openai/gpt-oss-120b&#39;, &#39;system_fingerprint&#39;: &#39;fp_ff6aa7708c&#39;, &#39;service_tier&#39;: &#39;on_demand&#39;, &#39;finish_reason&#39;: &#39;stop&#39;, &#39;logprobs&#39;: None, &#39;model_provider&#39;: &#39;groq&#39;}, id=&#39;lc_run--b676683a-da6e-4032-9114-172d53f13051-0&#39;, usage_metadata={&#39;input_tokens&#39;: 72, &#39;output_tokens&#39;: 41, &#39;total_tokens&#39;: 113})
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">agent</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Invokes the agent model to generate a response based on the current state. Given</span>
<span class="sd">    the question, it will decide to retrieve using the retriever tool, or simply end.</span>

<span class="sd">    Args:</span>
<span class="sd">        state (messages): The current state</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: The updated state with the agent response appended to messages</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---CALL AGENT---&quot;</span><span class="p">)</span>
    <span class="n">messages</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;messages&quot;</span><span class="p">]</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ChatGroq</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;openai/gpt-oss-120b&quot;</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">bind_tools</span><span class="p">(</span><span class="n">tools</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">messages</span><span class="p">)</span>
    <span class="c1"># We return a list, because this will get added to the existing list</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;messages&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">response</span><span class="p">]}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypedDict</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">langchain_classic.hub</span><span class="w"> </span><span class="kn">import</span> <span class="n">pull</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">langchain_core.messages</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseMessage</span><span class="p">,</span> <span class="n">HumanMessage</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">langchain_core.output_parsers</span><span class="w"> </span><span class="kn">import</span> <span class="n">StrOutputParser</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">langchain_core.prompts</span><span class="w"> </span><span class="kn">import</span> <span class="n">PromptTemplate</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pydantic</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### Edges</span>
<span class="k">def</span><span class="w"> </span><span class="nf">grade_documents</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;generate&quot;</span><span class="p">,</span> <span class="s2">&quot;rewrite&quot;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines whether the retrieved documents are relevant to the question.</span>

<span class="sd">    Args:</span>
<span class="sd">        state (messages): The current state</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: A decision for whether the documents are relevant or not</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---CHECK RELEVANCE---&quot;</span><span class="p">)</span>

    <span class="c1"># Data model</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">grade</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Binary score for relevance check.&quot;&quot;&quot;</span>

        <span class="n">binary_score</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Relevance score &#39;yes&#39; or &#39;no&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># LLM</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ChatGroq</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;openai/gpt-oss-120b&quot;</span><span class="p">)</span>

    <span class="c1"># LLM with tool and validation</span>
    <span class="n">llm_with_tool</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">with_structured_output</span><span class="p">(</span><span class="n">grade</span><span class="p">)</span>

    <span class="c1"># Prompt</span>
    <span class="n">prompt</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="p">(</span>
        <span class="n">template</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;You are a grader assessing relevance of a retrieved document to a user question. </span><span class="se">\n</span><span class="s2"> </span>
<span class="s2">        Here is the retrieved document: </span><span class="se">\n\n</span><span class="s2"> </span><span class="si">{context}</span><span class="s2"> </span><span class="se">\n\n</span>
<span class="s2">        Here is the user question: </span><span class="si">{question}</span><span class="s2"> </span><span class="se">\n</span>
<span class="s2">        If the document contains keyword(s) or semantic meaning related to the user question, grade it as relevant. </span><span class="se">\n</span>
<span class="s2">        Give a binary score &#39;yes&#39; or &#39;no&#39; score to indicate whether the document is relevant to the question.&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">input_variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;context&quot;</span><span class="p">,</span> <span class="s2">&quot;question&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Chain</span>
    <span class="n">chain</span> <span class="o">=</span> <span class="n">prompt</span> <span class="o">|</span> <span class="n">llm_with_tool</span>

    <span class="n">messages</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;messages&quot;</span><span class="p">]</span>
    <span class="n">last_message</span> <span class="o">=</span> <span class="n">messages</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">question</span> <span class="o">=</span> <span class="n">messages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">content</span>
    <span class="n">docs</span> <span class="o">=</span> <span class="n">last_message</span><span class="o">.</span><span class="n">content</span>

    <span class="n">scored_result</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span><span class="s2">&quot;question&quot;</span><span class="p">:</span> <span class="n">question</span><span class="p">,</span> <span class="s2">&quot;context&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="p">})</span>

    <span class="n">score</span> <span class="o">=</span> <span class="n">scored_result</span><span class="o">.</span><span class="n">binary_score</span>

    <span class="k">if</span> <span class="n">score</span> <span class="o">==</span> <span class="s2">&quot;yes&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---DECISION: DOCS RELEVANT---&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;generate&quot;</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---DECISION: DOCS NOT RELEVANT---&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;rewrite&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">generate</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate answer</span>

<span class="sd">    Args:</span>
<span class="sd">        state (messages): The current state</span>

<span class="sd">    Returns:</span>
<span class="sd">         dict: The updated message</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---GENERATE---&quot;</span><span class="p">)</span>
    <span class="n">messages</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;messages&quot;</span><span class="p">]</span>
    <span class="n">question</span> <span class="o">=</span> <span class="n">messages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">content</span>
    <span class="n">last_message</span> <span class="o">=</span> <span class="n">messages</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">docs</span> <span class="o">=</span> <span class="n">last_message</span><span class="o">.</span><span class="n">content</span>

    <span class="c1"># Prompt</span>
    <span class="n">prompt</span> <span class="o">=</span> <span class="n">pull</span><span class="p">(</span><span class="s2">&quot;rlm/rag-prompt&quot;</span><span class="p">)</span>

    <span class="c1"># LLM</span>
    <span class="n">llm</span> <span class="o">=</span> <span class="n">ChatGroq</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;openai/gpt-oss-120b&quot;</span><span class="p">)</span>

    <span class="c1"># Post-processing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_docs</span><span class="p">(</span><span class="n">docs</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">page_content</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">)</span>

    <span class="c1"># Chain</span>
    <span class="n">rag_chain</span> <span class="o">=</span> <span class="n">prompt</span> <span class="o">|</span> <span class="n">llm</span> <span class="o">|</span> <span class="n">StrOutputParser</span><span class="p">()</span>

    <span class="c1"># Run</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">rag_chain</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span><span class="s2">&quot;context&quot;</span><span class="p">:</span> <span class="n">docs</span><span class="p">,</span> <span class="s2">&quot;question&quot;</span><span class="p">:</span> <span class="n">question</span><span class="p">})</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;messages&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">response</span><span class="p">]}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">rewrite</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform the query to produce a better question.</span>

<span class="sd">    Args:</span>
<span class="sd">        state (messages): The current state</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: The updated state with re-phrased question</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---TRANSFORM QUERY---&quot;</span><span class="p">)</span>
    <span class="n">messages</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;messages&quot;</span><span class="p">]</span>
    <span class="n">question</span> <span class="o">=</span> <span class="n">messages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">content</span>

    <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">HumanMessage</span><span class="p">(</span>
            <span class="n">content</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot; </span><span class="se">\n</span><span class="s2"> </span>
<span class="s2">    Look at the input and try to reason about the underlying semantic intent / meaning. </span><span class="se">\n</span><span class="s2"> </span>
<span class="s2">    Here is the initial question:</span>
<span class="s2">    </span><span class="se">\n</span><span class="s2"> ------- </span><span class="se">\n</span>
<span class="s2">    </span><span class="si">{</span><span class="n">question</span><span class="si">}</span><span class="s2"> </span>
<span class="s2">    </span><span class="se">\n</span><span class="s2"> ------- </span><span class="se">\n</span>
<span class="s2">    Formulate an improved question: &quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># Grader</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ChatGroq</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s2">&quot;openai/gpt-oss-120b&quot;</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;messages&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">response</span><span class="p">]}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">langgraph.graph</span><span class="w"> </span><span class="kn">import</span> <span class="n">END</span><span class="p">,</span> <span class="n">StateGraph</span><span class="p">,</span> <span class="n">START</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">langgraph.prebuilt</span><span class="w"> </span><span class="kn">import</span> <span class="n">ToolNode</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">langgraph.prebuilt</span><span class="w"> </span><span class="kn">import</span> <span class="n">tools_condition</span>

<span class="c1"># Define a new graph</span>
<span class="n">workflow</span> <span class="o">=</span> <span class="n">StateGraph</span><span class="p">(</span><span class="n">AgentState</span><span class="p">)</span>

<span class="c1"># Define the nodes we will cycle between</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s2">&quot;agent&quot;</span><span class="p">,</span> <span class="n">agent</span><span class="p">)</span>  <span class="c1"># agent</span>
<span class="n">retrieve</span> <span class="o">=</span> <span class="n">ToolNode</span><span class="p">([</span><span class="n">retriever_tool</span><span class="p">,</span><span class="n">retriever_tool_langchain</span><span class="p">])</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s2">&quot;retrieve&quot;</span><span class="p">,</span> <span class="n">retrieve</span><span class="p">)</span>  <span class="c1"># retrieval</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="s2">&quot;rewrite&quot;</span><span class="p">,</span> <span class="n">rewrite</span><span class="p">)</span>  <span class="c1"># Re-writing the question</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span>
    <span class="s2">&quot;generate&quot;</span><span class="p">,</span> <span class="n">generate</span>
<span class="p">)</span>  <span class="c1"># Generating a response after we know the documents are relevant</span>
<span class="c1"># Call agent node to decide to retrieve or not</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">START</span><span class="p">,</span> <span class="s2">&quot;agent&quot;</span><span class="p">)</span>

<span class="c1"># Decide whether to retrieve</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_conditional_edges</span><span class="p">(</span>
    <span class="s2">&quot;agent&quot;</span><span class="p">,</span>
    <span class="c1"># Assess agent decision</span>
    <span class="n">tools_condition</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="c1"># Translate the condition outputs to nodes in our graph</span>
        <span class="s2">&quot;tools&quot;</span><span class="p">:</span> <span class="s2">&quot;retrieve&quot;</span><span class="p">,</span>
        <span class="n">END</span><span class="p">:</span> <span class="n">END</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">)</span>

<span class="c1"># Edges taken after the `action` node is called.</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_conditional_edges</span><span class="p">(</span>
    <span class="s2">&quot;retrieve&quot;</span><span class="p">,</span>
    <span class="c1"># Assess agent decision</span>
    <span class="n">grade_documents</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;generate&quot;</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
<span class="n">workflow</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s2">&quot;rewrite&quot;</span><span class="p">,</span> <span class="s2">&quot;agent&quot;</span><span class="p">)</span>

<span class="c1"># Compile</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">workflow</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">display</span>
<span class="n">display</span><span class="p">(</span><span class="n">Image</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">get_graph</span><span class="p">(</span><span class="n">xray</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">draw_mermaid_png</span><span class="p">()))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/82fccc2b9e8435fbab4092ee16a33a358b0e2a0bef56ca33d8f54162d55cef55.png" src="../_images/82fccc2b9e8435fbab4092ee16a33a358b0e2a0bef56ca33d8f54162d55cef55.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">graph</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span><span class="s2">&quot;messages&quot;</span><span class="p">:</span><span class="s2">&quot;What is Langgraph?&quot;</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>---CALL AGENT---
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;messages&#39;: [HumanMessage(content=&#39;What is Langgraph?&#39;, additional_kwargs={}, response_metadata={}, id=&#39;b66960aa-a4ee-4899-97a5-23b359e1a992&#39;),
  AIMessage(content=&#39;**LangGraph** is an open‑source Python library (maintained by the LangChain team) that makes it easy to build **stateful, multi‑step LLM applications as directed graphs**.  \n\n---\n\n## Core Idea\n\nInstead of writing a single “prompt‑then‑response” chain, you describe your application as a **graph of nodes** (functions, prompts, agents, or other components) and **edges** that dictate how data (the *state*) flows from one step to the next.  \nThe runtime walks the graph, updates the state, and can branch, loop, or wait for external events—exactly the kind of control‑flow that more complex AI products need (chat assistants, data pipelines, autonomous agents, etc.).\n\n---\n\n## Key Concepts\n\n| Concept | What it is | Typical use |\n|---------|------------|-------------|\n| **Node** | A callable (LLM chain, tool, custom function, LangChain agent, etc.) that receives the current state and returns a partial result. | “Ask the LLM for a summary”, “Call a web‑search tool”, “Store data in a DB”. |\n| **State** | A mutable dictionary (or any serializable object) that travels through the graph, accumulating results, flags, and context. | Holds conversation history, extracted entities, intermediate calculations. |\n| **Edge / Transition** | A rule that decides which node(s) to run next based on the current state (e.g., `if state[&quot;needs_search&quot;]: → search_node`). | Conditional branching, loops, retries. |\n| **Graph** | The full DAG/flowchart of nodes and edges. It can be static (defined once) or dynamically altered at runtime. | End‑to‑end workflow for a customer‑support bot, a data‑extraction pipeline, etc. |\n| **Runner** | The execution engine that steps through the graph, updates the state, and respects async/sync semantics. | Handles parallel branches, retries, timeouts, and persistence. |\n\n---\n\n## Why Use LangGraph?\n\n| Challenge | LangGraph’s Solution |\n|-----------|----------------------|\n| **Complex control flow** (if/else, loops, sub‑graphs) | Declarative edges + state‑driven routing replace brittle `if` statements. |\n| **Memory &amp; context management** | The shared state persists across nodes, so you can store LLM‑generated facts, tool outputs, or user data without re‑prompting. |\n| **Composable building blocks** | Nodes are just callables; you can reuse existing LangChain chains, LangServe APIs, or any Python function. |\n| **Observability &amp; debugging** | The runtime logs each node execution, state snapshots, and timings—making it easy to trace failures. |\n| **Scalability** | Supports async execution, parallel branches, and can be deployed with LangServe or other serverless back‑ends. |\n| **Tool integration** | Nodes can call external APIs, databases, or custom tools, enabling “agentic” behavior. |\n\n---\n\n## Typical Use Cases\n\n| Use case | How LangGraph helps |\n|----------|----------------------|\n| **Customer‑support chatbot** | Branch to FAQ retrieval, knowledge‑base search, or escalation based on intent detection stored in state. |\n| **Data extraction pipeline** | Loop over documents, run LLM extraction, validate with a schema, and write to a DB, retrying on validation failures. |\n| **Autonomous agents** | Combine planning nodes, tool‑calling nodes, and reflection loops to let an agent iteratively solve a task. |\n| **Multi‑modal workflows** | Mix image‑processing nodes, LLM summarization, and audio transcription in a single graph. |\n| **Human‑in‑the‑loop review** | Pause the graph, present state to a reviewer, then resume based on their feedback. |\n\n---\n\n## Minimal Example\n\n```python\nfrom langgraph.graph import StateGraph, END\nfrom langchain.llms import OpenAI\nfrom langchain.prompts import PromptTemplate\n\n# 1️⃣ Define the shared state schema (optional, but helpful)\nclass MyState(dict):\n    &quot;&quot;&quot;A simple dict‑based state.&quot;&quot;&quot;\n    pass\n\n# 2️⃣ Create the graph\ngraph = StateGraph(MyState)\n\n# 3️⃣ Nodes -------------------------------------------------\ndef greet(state: MyState):\n    return {&quot;message&quot;: &quot;Hello! How can I help you today?&quot;}\n\ndef classify_intent(state: MyState):\n    llm = OpenAI()\n    prompt = PromptTemplate.from_template(\n        &quot;User: {user_input}\\nDetermine the intent (search|faq|escalate).&quot;\n    )\n    intent = llm.invoke(prompt.format(user_input=state[&quot;user_input&quot;]))\n    return {&quot;intent&quot;: intent.strip().lower()}\n\ndef search(state: MyState):\n    # pretend we call a search API\n    return {&quot;search_results&quot;: f&quot;Results for {state[\&#39;user_input\&#39;]}&quot;}\n\ndef faq(state: MyState):\n    return {&quot;answer&quot;: &quot;Here is the FAQ entry you asked for.&quot;}\n\ndef escalate(state: MyState):\n    return {&quot;escalated&quot;: True, &quot;message&quot;: &quot;Connecting you to a human agent.&quot;}\n\n# Register nodes\ngraph.add_node(&quot;greet&quot;, greet)\ngraph.add_node(&quot;classify&quot;, classify_intent)\ngraph.add_node(&quot;search&quot;, search)\ngraph.add_node(&quot;faq&quot;, faq)\ngraph.add_node(&quot;escalate&quot;, escalate)\n\n# 4️⃣ Transitions (edges) ---------------------------------\ngraph.set_entry_point(&quot;greet&quot;)\ngraph.add_edge(&quot;greet&quot;, &quot;classify&quot;)\n\n# Conditional routing based on the intent stored in state\ngraph.add_conditional_edges(\n    &quot;classify&quot;,\n    lambda state: {\n        &quot;search&quot;: &quot;search&quot;,\n        &quot;faq&quot;: &quot;faq&quot;,\n        &quot;escalate&quot;: &quot;escalate&quot;,\n    }[state[&quot;intent&quot;]],\n)\n\n# End each leaf node\ngraph.add_edge(&quot;search&quot;, END)\ngraph.add_edge(&quot;faq&quot;, END)\ngraph.add_edge(&quot;escalate&quot;, END)\n\n# 5️⃣ Compile &amp; run ---------------------------------------\napp = graph.compile()\n\n# Run a single turn\nresult = app.invoke({&quot;user_input&quot;: &quot;What are your opening hours?&quot;})\nprint(result)\n```\n\n*Output (simplified)*\n\n```json\n{\n  &quot;message&quot;: &quot;Hello! How can I help you today?&quot;,\n  &quot;user_input&quot;: &quot;What are your opening hours?&quot;,\n  &quot;intent&quot;: &quot;faq&quot;,\n  &quot;answer&quot;: &quot;Here is the FAQ entry you asked for.&quot;\n}\n```\n\nThe graph automatically:\n\n1. Greets the user.  \n2. Classifies intent.  \n3. Routes to the appropriate node.  \n4. Returns the final state.\n\n---\n\n## How It Relates to the Rest of the LangChain Ecosystem\n\n| LangChain component | Role | Interaction with LangGraph |\n|---------------------|------|----------------------------|\n| **Chains** | Sequential LLM calls | Chains can be wrapped as nodes. |\n| **Agents** | Tool‑calling logic | Agents become nodes that may update state with tool results. |\n| **LangServe** | Deployable API endpoints | A compiled LangGraph can be served via LangServe for production. |\n| **Memory** | Persistent context across turns | LangGraph’s state can replace or augment LangChain’s memory objects. |\n| **Callbacks** | Observability | LangGraph forwards callbacks, letting you plug in logging, tracing, or LangChain‑compatible telemetry. |\n\n---\n\n## Getting Started\n\n1. **Install**  \n   ```bash\n   pip install langgraph\n   # (LangChain is a peer dependency, install it if you haven’t)\n   pip install langchain openai\n   ```\n\n2. **Read the docs** – the official docs contain a “Getting Started” tutorial, a reference for `StateGraph`, and several real‑world examples.  \n   &lt;https://python.langchain.com/docs/langgraph/&gt;\n\n3. **Explore the examples** – the repo ships with notebooks for:\n   * Chat bots with memory  \n   * Retrieval‑augmented generation pipelines  \n   * Multi‑agent coordination  \n\n4. **Deploy** – once you have a compiled graph (`graph.compile()`), you can expose it with LangServe:\n\n   ```bash\n   langserve run my_graph:app\n   ```\n\n---\n\n## Limitations &amp; Things to Watch\n\n| Issue | Mitigation |\n|-------|------------|\n| **State size** – the whole state is passed between nodes, so very large objects can become a performance bottleneck. | Keep the state lean; store heavy data (e.g., PDFs, images) in external storage and reference via IDs. |\n| **Cyclic graphs** – LangGraph supports loops but you must guard against infinite recursion. | Use explicit counters or timeout conditions in your transition functions. |\n| **Debugging complex flows** – many branches can make it hard to see why a particular path was taken. | Enable the built‑in `GraphTracer` callback; it logs each node, the state snapshot before/after, and the chosen edge. |\n| **Version compatibility** – LangGraph evolves quickly; pin the version (`langgraph==0.0.x`) in production. | Follow the release notes and upgrade tests. |\n\n---\n\n## TL;DR Summary\n\n- **LangGraph** = a **graph‑oriented execution engine** for LLM‑driven applications.  \n- You define **nodes** (any callable) and **edges** (state‑based routing).  \n- A shared **state** travels through the graph, giving you memory, branching, loops, and tool integration in a clean, observable way.  \n- It sits on top of **LangChain**, letting you reuse existing chains, agents, and tools while adding structured control flow.  \n- Ideal for chat bots, autonomous agents, data pipelines, and any multi‑step AI product that needs more than a single prompt‑response cycle.  \n\nIf you’re building anything beyond a trivial “LLM‑only” script, LangGraph is the recommended way to structure your code for **clarity, composability, and production readiness**.&#39;, additional_kwargs={&#39;reasoning_content&#39;: &#39;The user asks &quot;What is Langgraph?&quot; We need to answer. We should provide a concise explanation. Possibly include details: LangGraph is a library for building stateful LLM applications, part of LangChain ecosystem, enabling creation of multi-step workflows, graph structures, conditional logic, memory, etc. Provide overview, features, use cases, maybe example. No need to call external functions unless we want up-to-date info. We have knowledge cutoff 2024-06, but can answer based on that. Provide thorough answer.&#39;}, response_metadata={&#39;token_usage&#39;: {&#39;completion_tokens&#39;: 2198, &#39;prompt_tokens&#39;: 172, &#39;total_tokens&#39;: 2370, &#39;completion_time&#39;: 4.598375392, &#39;prompt_time&#39;: 0.007018561, &#39;queue_time&#39;: 0.049013918, &#39;total_time&#39;: 4.605393953}, &#39;model_name&#39;: &#39;openai/gpt-oss-120b&#39;, &#39;system_fingerprint&#39;: &#39;fp_1d1727abc9&#39;, &#39;service_tier&#39;: &#39;on_demand&#39;, &#39;finish_reason&#39;: &#39;stop&#39;, &#39;logprobs&#39;: None, &#39;model_provider&#39;: &#39;groq&#39;}, id=&#39;lc_run--67abf5a3-2dad-4200-ab0b-010ec0e7cbe6-0&#39;, usage_metadata={&#39;input_tokens&#39;: 172, &#39;output_tokens&#39;: 2198, &#39;total_tokens&#39;: 2370})]}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">graph</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span><span class="s2">&quot;messages&quot;</span><span class="p">:</span><span class="s2">&quot;What is Langchain?&quot;</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>---CALL AGENT---
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;messages&#39;: [HumanMessage(content=&#39;What is Langchain?&#39;, additional_kwargs={}, response_metadata={}, id=&#39;b3d4cd64-fc92-4abb-b837-e9493646a352&#39;),
  AIMessage(content=&#39;**LangChain** is an open‑source framework for building applications that are powered by large language models (LLMs). It provides the building blocks, abstractions, and utilities you need to combine LLMs with external data sources, tools, and custom logic so you can create sophisticated, “chainable” AI‑driven workflows.\n\nBelow is a concise overview of what LangChain is, why it exists, its core concepts, and typical use‑cases.\n\n---\n\n## 1️⃣ What Problem Does LangChain Solve?\n\nLLMs are great at generating text, but real‑world AI products often need more than a single prompt‑completion call. Typical requirements include:\n\n| Requirement | Why a plain LLM call isn’t enough |\n|-------------|-----------------------------------|\n| **Access to external data** (databases, APIs, documents) | LLMs only know what they were trained on; they can’t query up‑to‑date information. |\n| **Multi‑step reasoning** (e.g., “search → retrieve → summarize → answer”) | One prompt can’t orchestrate a sequence of actions. |\n| **Tool usage** (e.g., calling a calculator, web scraper, or code executor) | LLMs need a way to invoke external tools safely. |\n| **Stateful interactions** (memory across turns, session context) | LLMs are stateless; you need a way to store and retrieve past information. |\n| **Custom business logic** (validation, routing, fallback) | Pure generation can’t enforce domain‑specific rules. |\n\nLangChain abstracts these patterns into reusable components, letting developers focus on *what* they want to achieve rather than *how* to wire everything together.\n\n---\n\n## 2️⃣ Core Concepts (the “building blocks”)\n\n| Component | Description | Typical Use |\n|-----------|--------------|-------------|\n| **LLM Wrappers** | Thin adapters around OpenAI, Anthropic, Cohere, Llama‑2, Gemini, etc., handling API calls, token limits, streaming, etc. | Generate text, embeddings, or chat completions. |\n| **Prompt Templates** | Structured ways to create prompts with variables, partials, and dynamic formatting. | Reuse a “question‑answer” prompt across many queries. |\n| **Chains** | Sequential pipelines where the output of one component feeds into the next (e.g., *LLM → Parser → API call → LLM*). | Build a “search‑then‑summarize” workflow. |\n| **Agents** | Dynamic systems that decide **which** tool or chain to invoke next, based on LLM‑generated reasoning. | A chatbot that can browse the web, run code, or query a database on the fly. |\n| **Memory** | State‑management utilities (ConversationBuffer, Summarizer, VectorStoreRetrieverMemory, etc.) that persist context across turns. | Keep track of a multi‑turn conversation. |\n| **Retrievers / Vector Stores** | Indexes (FAISS, Pinecone, Weaviate, Chroma, etc.) that enable similarity search over embeddings. | Retrieve relevant docs before answering a question. |\n| **Tools** | Wrappers around external services (search engines, calculators, SQL DBs, custom APIs). | Let an LLM call a weather API or run a Python script. |\n| **Callbacks &amp; Logging** | Hooks for tracing, debugging, and observability (e.g., LangSmith integration). | Monitor token usage, latency, and error handling. |\n| **Evaluation &amp; Testing** | Utilities for benchmark datasets, answer grading, and synthetic data generation. | Validate that a chain meets quality criteria before deployment. |\n\nAll of these pieces can be combined in a **modular** fashion, allowing you to start with a simple chain and progressively add complexity (memory, agents, tool use, etc.) as your product evolves.\n\n---\n\n## 3️⃣ Typical Architectures Built with LangChain\n\n| Application | LangChain Pattern(s) Used | Example Flow |\n|-------------|---------------------------|--------------|\n| **Chatbot with up‑to‑date knowledge** | Retriever → LLM → Memory | 1️⃣ User asks a question → 2️⃣ Retriever fetches relevant docs → 3️⃣ LLM generates answer using docs + conversation memory. |\n| **Question‑Answering over private docs** | VectorStoreRetriever → RetrievalQAChain | Docs are embedded → stored in a vector DB → query → top‑k docs → LLM synthesizes answer. |\n| **Agentic web assistant** | Agent (LLM decides) + Tools (search, browser, calculator) | LLM reads user request → decides to call a web‑search tool → extracts info → may call calculator → returns final answer. |\n| **Data extraction / ETL** | LLM → Structured Output Parser → Database Writer | LLM reads raw text → parses into JSON → code writes rows into a SQL table. |\n| **Code generation &amp; execution** | Agent + Python REPL tool | User asks for a function → agent writes code → sends to Python REPL → captures output → returns result. |\n| **Workflow automation** | Chains of multiple APIs (CRM, email, calendar) | LLM generates email content → tool sends email → chain updates CRM record. |\n\n---\n\n## 4️⃣ Why Choose LangChain?\n\n| Benefit | Explanation |\n|---------|-------------|\n| **Productivity** – Pre‑built wrappers, prompt utilities, and chain templates reduce boilerplate. |\n| **Extensibility** – Plug in any LLM, vector store, or custom tool; the framework is language‑agnostic (Python, JavaScript/TypeScript, Java, .NET). |\n| **Community &amp; Ecosystem** – Active open‑source community, extensive docs, and a growing marketplace of community‑contributed components. |\n| **Observability** – Integration with LangSmith (a tracing/monitoring platform) helps you debug and improve pipelines. |\n| **Safety** – Built‑in patterns for sandboxed tool execution, token‑budget handling, and output validation. |\n| **Scalability** – Works with both local models (e.g., Llama‑2 on GPU) and hosted APIs; you can swap providers without rewriting logic. |\n\n---\n\n## 5️⃣ Getting Started (Python Example)\n\n```python\n# Install the core library\n# pip install langchain openai tiktoken  # plus any vector store you need\n\nfrom langchain.llms import OpenAI\nfrom langchain.prompts import PromptTemplate\nfrom langchain.chains import LLMChain\nfrom langchain.memory import ConversationBufferMemory\n\n# 1️⃣ Set up the LLM (OpenAI gpt‑4 in this case)\nllm = OpenAI(model=&quot;gpt-4&quot;, temperature=0)\n\n# 2️⃣ Define a reusable prompt\ntemplate = &quot;&quot;&quot;You are a helpful assistant.\nUser: {question}\nAnswer concisely and factually.&quot;&quot;&quot;\nprompt = PromptTemplate.from_template(template)\n\n# 3️⃣ Create a chain that ties prompt + LLM together\nqa_chain = LLMChain(llm=llm, prompt=prompt)\n\n# 4️⃣ Add memory so the assistant remembers prior turns\nmemory = ConversationBufferMemory()\nqa_chain.memory = memory\n\n# 5️⃣ Run the chain\nwhile True:\n    user_input = input(&quot;You: &quot;)\n    if user_input.lower() in {&quot;exit&quot;, &quot;quit&quot;}:\n        break\n    answer = qa_chain.run(question=user_input)\n    print(&quot;Assistant:&quot;, answer)\n```\n\n*What’s happening?*\n\n1. **LLM wrapper** handles the API call.  \n2. **PromptTemplate** injects the user’s question into a static prompt.  \n3. **LLMChain** ties the two together.  \n4. **ConversationBufferMemory** stores previous exchanges, so the LLM can see the full dialogue.\n\nFrom here you could attach a **Retriever** (e.g., `Chroma` vector store) to make the chain *RetrievalQAChain*, or switch the chain to an **Agent** that can call external tools.\n\n---\n\n## 6️⃣ Resources &amp; Further Reading\n\n| Resource | Link |\n|----------|------|\n| **Official Docs** | https://python.langchain.com/ |\n| **LangChain Hub** (pre‑made prompts, chains, agents) | https://smith.langchain.com/hub |\n| **LangSmith** (observability, tracing) | https://smith.langchain.com/ |\n| **Tutorials** | “Building a Retrieval‑Augmented Generation (RAG) app” (official tutorial) |\n| **Community** | Discord, GitHub Discussions, weekly newsletter |\n| **Blog Posts** | “LangChain 101: From Prompt to Production” (2023) – a good primer |\n\n---\n\n### TL;DR\n\n**LangChain** is a modular framework that lets developers stitch together LLMs, prompts, memory, retrieval, and external tools into coherent, multi‑step AI applications. It abstracts away the plumbing, provides reusable components (chains, agents, retrievers, memory), and offers observability tools, making it far easier to build production‑grade LLM‑powered products.&#39;, additional_kwargs={&#39;reasoning_content&#39;: &#39;User asks: &quot;What is Langchain?&quot; Provide explanation. Could add details. Use knowledge up to 2024. No need to call functions.&#39;}, response_metadata={&#39;token_usage&#39;: {&#39;completion_tokens&#39;: 1930, &#39;prompt_tokens&#39;: 172, &#39;total_tokens&#39;: 2102, &#39;completion_time&#39;: 4.019129002, &#39;prompt_time&#39;: 0.006625734, &#39;queue_time&#39;: 0.047402536, &#39;total_time&#39;: 4.025754736}, &#39;model_name&#39;: &#39;openai/gpt-oss-120b&#39;, &#39;system_fingerprint&#39;: &#39;fp_e88ce9c728&#39;, &#39;service_tier&#39;: &#39;on_demand&#39;, &#39;finish_reason&#39;: &#39;stop&#39;, &#39;logprobs&#39;: None, &#39;model_provider&#39;: &#39;groq&#39;}, id=&#39;lc_run--38d35fb5-0d58-42d5-8d23-bd07f233fff2-0&#39;, usage_metadata={&#39;input_tokens&#39;: 172, &#39;output_tokens&#39;: 1930, &#39;total_tokens&#39;: 2102})]}
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">graph</span><span class="o">.</span><span class="n">invoke</span><span class="p">({</span><span class="s2">&quot;messages&quot;</span><span class="p">:</span><span class="s2">&quot;What is Machine learning?&quot;</span><span class="p">})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>---CALL AGENT---
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;messages&#39;: [HumanMessage(content=&#39;What is Machine learning?&#39;, additional_kwargs={}, response_metadata={}, id=&#39;18fe6271-f608-4bb8-b825-d5c226066f8d&#39;),
  AIMessage(content=&#39;**Machine learning (ML)** is a subfield of artificial intelligence (AI) that focuses on developing algorithms and statistical models that enable computers to learn from data and improve their performance on a specific task without being explicitly programmed for every possible scenario.\n\n### Key Points\n\n| Aspect | Explanation |\n|--------|--------------|\n| **Core Idea** | Instead of writing explicit rules, we let the system discover patterns and relationships from examples (data). |\n| **Learning Process** | The algorithm is trained on a **training dataset** (input‑output pairs or unlabeled data). It then **generalizes** to make predictions or decisions on new, unseen data. |\n| **Types of Learning** | • **Supervised Learning** – learns from labeled data (e.g., classification, regression).&lt;br&gt;• **Unsupervised Learning** – discovers structure in unlabeled data (e.g., clustering, dimensionality reduction).&lt;br&gt;• **Semi‑supervised Learning** – combines a small amount of labeled data with a large amount of unlabeled data.&lt;br&gt;• **Reinforcement Learning** – learns by interacting with an environment and receiving rewards/punishments. |\n| **Common Algorithms** | Linear regression, logistic regression, decision trees, random forests, support vector machines, k‑nearest neighbors, k‑means clustering, principal component analysis (PCA), neural networks, deep learning models (CNNs, RNNs, Transformers). |\n| **Typical Workflow** | 1. **Data Collection &amp; Preparation** – gather, clean, and preprocess data.&lt;br&gt;2. **Feature Engineering** – create informative inputs for the model.&lt;br&gt;3. **Model Selection &amp; Training** – choose an algorithm and fit it to the training data.&lt;br&gt;4. **Evaluation** – assess performance using metrics (accuracy, precision, recall, F1, RMSE, etc.) on a validation/test set.&lt;br&gt;5. **Deployment &amp; Monitoring** – integrate the model into production and continuously monitor its performance. |\n| **Why It Matters** | • Enables automation of complex tasks (e.g., image recognition, language translation).&lt;br&gt;• Powers recommendation systems, fraud detection, predictive maintenance, medical diagnosis, autonomous vehicles, and many other applications.&lt;br&gt;• Allows systems to adapt over time as new data becomes available. |\n| **Challenges** | Data quality &amp; bias, overfitting/underfitting, interpretability, computational cost, ethical concerns (privacy, fairness). |\n\n### Simple Analogy\n\nThink of teaching a child to recognize cats. Instead of describing every possible cat feature, you show the child many pictures of cats and non‑cats. Over time, the child learns to identify the visual patterns that differentiate a cat from other objects. Machine learning does the same thing, but with mathematical models and digital data.\n\n### Bottom Line\n\nMachine learning provides the tools for computers to **learn from experience** (data), **generalize** to new situations, and **make intelligent decisions** with minimal human‑coded rules. It’s the engine behind many modern AI applications we use daily.&#39;, additional_kwargs={&#39;reasoning_content&#39;: &#39;The user asks: &quot;What is Machine learning?&quot; Provide a definition. Simple answer.&#39;}, response_metadata={&#39;token_usage&#39;: {&#39;completion_tokens&#39;: 656, &#39;prompt_tokens&#39;: 172, &#39;total_tokens&#39;: 828, &#39;completion_time&#39;: 1.370919913, &#39;prompt_time&#39;: 0.00667166, &#39;queue_time&#39;: 0.05459493, &#39;total_time&#39;: 1.3775915730000001}, &#39;model_name&#39;: &#39;openai/gpt-oss-120b&#39;, &#39;system_fingerprint&#39;: &#39;fp_ff6aa7708c&#39;, &#39;service_tier&#39;: &#39;on_demand&#39;, &#39;finish_reason&#39;: &#39;stop&#39;, &#39;logprobs&#39;: None, &#39;model_provider&#39;: &#39;groq&#39;}, id=&#39;lc_run--3167fea7-b311-443f-b5a5-f3bb0d75a511-0&#39;, usage_metadata={&#39;input_tokens&#39;: 172, &#39;output_tokens&#39;: 656, &#39;total_tokens&#39;: 828})]}
</pre></div>
</div>
</div>
</div>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./6-RAGS"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Agentic RAG</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#langchain-blogs-seperate-vector-store">Langchain Blogs- Seperate Vector Store</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#langgraph-workflow">LangGraph Workflow</a></li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Your Name
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright © 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>